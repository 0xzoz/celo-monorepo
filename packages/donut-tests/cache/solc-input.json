{
  "language": "Solidity",
  "sources": {
    "contracts/Passthrough.sol": {
      "content": "//SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.5.10;\n\nimport {CeloB12_377Lib} from \"@celo/protocol/contracts/common/libraries/B12.sol\";\nimport {B12} from \"@celo/protocol/contracts/common/libraries/B12.sol\";\nimport {TypedMemView} from \"@summa-tx/memview.sol/contracts/TypedMemView.sol\";\n\ncontract Passthrough {\n    using CeloB12_377Lib for B12.G1Point;\n    using CeloB12_377Lib for B12.G2Point;\n    using CeloB12_377Lib for B12.Fp;\n    using CeloB12_377Lib for B12.Fp2;\n    using B12 for B12.G1Point;\n    using B12 for B12.G2Point;\n    using B12 for B12.Fp;\n    using B12 for B12.Fp2;\n    using CeloB12_377Lib for bytes;\n    using B12 for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    constructor() public {}\n\n    event MEMDUMP(uint256 a, uint256 b, uint256 c, uint256 d);\n\n    function dumpMem(uint256 idx) internal {\n        uint256 a;\n        uint256 b;\n        uint256 c;\n        uint256 d;\n\n        assembly {\n            a := mload(add(idx, 0x00))\n            b := mload(add(idx, 0x20))\n            c := mload(add(idx, 0x40))\n            d := mload(add(idx, 0x60))\n        }\n        emit MEMDUMP(a, b, c, d);\n    }\n\n    function executePrecompile(\n        bytes memory input,\n        uint8 addr,\n        uint256 output_len\n    ) internal view returns (bytes memory output) {\n        bool success;\n        assembly {\n            success := staticcall(\n                sub(gas(), 2000),\n                addr,\n                add(input, 0x20), // location\n                mload(input), // length\n                add(output, 0x20), // location\n                output_len // length\n            )\n            mstore(output, output_len)\n        }\n\n        require(success, \"failed\");\n    }\n\n    function simple(\n        bytes calldata input,\n        uint8 addr,\n        uint256 output_len\n    ) external view returns (bytes memory) {\n        return executePrecompile(input, addr, output_len);\n    }\n\n    function simpleTx(\n        bytes calldata input,\n        uint8 addr,\n        uint256 output_len\n    ) external returns (bytes memory output) {\n        output = executePrecompile(input, addr, output_len);\n        uint256 a;\n        assembly {\n            a := output\n        }\n        dumpMem(a + 0x20);\n        return output;\n    }\n\n    function g1Add(bytes calldata args) external view returns (bytes memory) {\n        B12.G1Point memory a = args.parseG1(0);\n        B12.G1Point memory b = args.parseG1(4 * 32);\n        return a.g1Add(b).serializeG1();\n    }\n\n    function g1Mul(bytes calldata args) external view returns (bytes memory) {\n        B12.G1Point memory a = args.parseG1(0);\n        uint256 scalar = args.ref(0).indexUint(4 * 32, 32);\n        return a.g1Mul(scalar).serializeG1();\n    }\n\n    function g1MultiExp(bytes calldata args)\n        external\n        view\n        returns (bytes memory)\n    {\n        bytes29 ref = args.ref(0);\n\n\n        B12.G1MultiExpArg[] memory input\n         = new B12.G1MultiExpArg[](args.length / 160);\n\n        for (uint256 i = 0; i < args.length / 160; i += 1) {\n            uint256 idx = i * 160;\n\n            input[i].point.X.a = ref.indexUint(idx + 0x00, 32);\n            input[i].point.X.b = ref.indexUint(idx + 0x20, 32);\n            input[i].point.Y.a = ref.indexUint(idx + 0x40, 32);\n            input[i].point.Y.b = ref.indexUint(idx + 0x60, 32);\n            input[i].scalar = ref.indexUint(idx + 0x80, 32);\n        }\n\n        return CeloB12_377Lib.g1MultiExp(input).serializeG1();\n    }\n\n    function g2Add(bytes calldata args) external view returns (bytes memory) {\n        B12.G2Point memory a = args.parseG2(0);\n        B12.G2Point memory b = args.parseG2(8 * 32);\n        return a.g2Add(b).serializeG2();\n    }\n\n    function g2Mul(bytes calldata args) external view returns (bytes memory) {\n        B12.G2Point memory a = args.parseG2(0);\n        uint256 scalar = args.ref(0).indexUint(8 * 32, 32);\n        a.g2Mul(scalar);\n        return a.serializeG2();\n    }\n\n    function g2MultiExp(bytes calldata args)\n        external\n        view\n        returns (bytes memory)\n    {\n        bytes29 ref = args.ref(0);\n\n\n        B12.G2MultiExpArg[] memory input\n         = new B12.G2MultiExpArg[](args.length / 288);\n\n        for (uint256 i = 0; i < args.length / 288; i += 1) {\n            uint256 idx = i * 288;\n\n            input[i].point.X.a.a = ref.indexUint(idx + 0x00, 32);\n            input[i].point.X.a.b = ref.indexUint(idx + 0x20, 32);\n            input[i].point.X.b.a = ref.indexUint(idx + 0x40, 32);\n            input[i].point.X.b.b = ref.indexUint(idx + 0x60, 32);\n            input[i].point.Y.a.a = ref.indexUint(idx + 0x80, 32);\n            input[i].point.Y.a.b = ref.indexUint(idx + 0xa0, 32);\n            input[i].point.Y.b.a = ref.indexUint(idx + 0xc0, 32);\n            input[i].point.Y.b.b = ref.indexUint(idx + 0xe0, 32);\n            input[i].scalar = ref.indexUint(idx + 0x100, 32);\n        }\n\n        return CeloB12_377Lib.g2MultiExp(input).serializeG2();\n    }\n\n    function testParseG1(bytes calldata arg)\n        external\n        pure\n        returns (uint256[4] memory ret)\n    {\n        B12.G1Point memory a = arg.parseG1(0);\n        ret[0] = a.X.a;\n        ret[1] = a.X.b;\n        ret[2] = a.Y.a;\n        ret[3] = a.Y.b;\n    }\n\n    function testSerializeG1(\n        uint256 w,\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) external pure returns (bytes memory) {\n        B12.G1Point memory a;\n        a.X.a = w;\n        a.X.b = x;\n        a.Y.a = y;\n        a.Y.b = z;\n\n        return a.serializeG1();\n    }\n\n    function testParseG2(bytes calldata arg)\n        external\n        pure\n        returns (uint256[8] memory ret)\n    {\n        B12.G2Point memory a = arg.parseG2(0);\n        ret[0] = a.X.a.a;\n        ret[1] = a.X.a.b;\n        ret[2] = a.X.b.a;\n        ret[3] = a.X.b.b;\n        ret[4] = a.Y.a.a;\n        ret[5] = a.Y.a.b;\n        ret[6] = a.Y.b.a;\n        ret[7] = a.Y.b.b;\n    }\n\n    function testSerializeG2(\n        uint256 xaa,\n        uint256 xab,\n        uint256 xba,\n        uint256 xbb,\n        uint256 yaa,\n        uint256 yab,\n        uint256 yba,\n        uint256 ybb\n    ) external pure returns (bytes memory) {\n        B12.G2Point memory a;\n        a.X.a.a = xaa;\n        a.X.a.b = xab;\n        a.X.b.a = xba;\n        a.X.b.b = xbb;\n        a.Y.a.a = yaa;\n        a.Y.a.b = yab;\n        a.Y.b.a = yba;\n        a.Y.b.b = ybb;\n\n        return a.serializeG2();\n    }\n\n    function fpMulTest(uint256 a1, uint256 a2, uint256 b1, uint256 b2) external view returns (uint256, uint256) {\n        B12.Fp memory a = B12.Fp(a1, a2);\n        B12.Fp memory b = B12.Fp(b1, b2);\n        B12.Fp memory res = B12.fpMul(a, b);\n        return (res.a, res.b);\n    }\n\n    function fpNormalTest(uint256 a1, uint256 a2) external view returns (uint256, uint256) {\n        B12.Fp memory a = B12.Fp(a1, a2);\n        B12.Fp memory res = B12.fpNormal(a);\n        return (res.a, res.b);\n    }\n\n    function fpNormal2Test(uint256 a, uint256 idx) external view returns (uint256, uint256) {\n        B12.Fp memory res = B12.fpNormal2(B12.Fp(0,a), idx);\n        return (res.a, res.b);\n    }\n\n    function fp2MulTest(uint256[] calldata arr) external view returns (uint256, uint256, uint256, uint256) {\n        B12.Fp2 memory x = B12.Fp2(B12.Fp(arr[0], arr[1]), B12.Fp(arr[2], arr[3]));\n        B12.Fp2 memory y = B12.Fp2(B12.Fp(arr[4], arr[5]), B12.Fp(arr[6], arr[7]));\n        B12.Fp2 memory res = B12.fp2Mul(x, y);\n        return (res.a.a, res.a.b, res.b.a, res.b.b);\n    }\n\n    function testUncompress() external view returns (uint256, uint256) {\n        B12.Fp memory x = B12.Fp(0x008848defe740a67c8fc6225bf87ff54, 0x85951e2caa9d41bb188282c8bd37cb5cd5481512ffcd394eeab9b16eb21be9ef);\n        B12.Fp memory y1 = B12.Fp(0x001cefdc52b4e1eba6d3b6633bf15a76, 0x5ca326aa36b6c0b5b1db375b6a5124fa540d200dfb56a6e58785e1aaaa63715b);\n        B12.Fp memory y2 = B12.Fp(0x01914a69c5102eff1f674f5d30afeec4, 0xbd7fb348ca3e52d96d182ad44fb82305c2fe3d3634a9591afd82de55559c8ea6);\n        B12.G1Point memory res = B12.mapToG1(x, y2, y1, true);\n        return (res.Y.a, res.Y.b);\n    }\n\n    function testDeserialize(bytes memory h) public pure returns (uint256, uint256, bool) {\n        (B12.Fp memory p, bool b) = B12.parsePoint(h);\n        return (p.a, p.b, b);\n    }\n\n}\n"
    },
    "@celo/protocol/contracts/common/libraries/B12.sol": {
      "content": "//SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.5.8;\n\n// largely based on\n// https://github.com/ralexstokes/deposit-verifier/blob/master/deposit_verifier.sol\n\nimport { TypedMemView } from \"@summa-tx/memview.sol/contracts/TypedMemView.sol\";\n\nlibrary B12 {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // Fp is a field element with the high-order part stored in `a`.\n  struct Fp {\n    uint256 a;\n    uint256 b;\n  }\n\n  // Fp2 is an extension field element with the coefficient of the\n  // quadratic non-residue stored in `b`, i.e. p = a + i * b\n  struct Fp2 {\n    Fp a;\n    Fp b;\n  }\n\n  // G1Point represents a point on BLS12-377 over Fp with coordinates (X,Y);\n  struct G1Point {\n    Fp X;\n    Fp Y;\n  }\n\n  // G2Point represents a point on BLS12-377 over Fp2 with coordinates (X,Y);\n  struct G2Point {\n    Fp2 X;\n    Fp2 Y;\n  }\n\n  struct G1MultiExpArg {\n    G1Point point;\n    uint256 scalar;\n  }\n\n  struct G2MultiExpArg {\n    G2Point point;\n    uint256 scalar;\n  }\n\n  struct PairingArg {\n    G1Point g1;\n    G2Point g2;\n  }\n\n  function FpEq(Fp memory a, Fp memory b) internal pure returns (bool) {\n    return (a.a == b.a && a.b == b.b);\n  }\n\n  function fpGt(Fp memory a, Fp memory b) internal pure returns (bool) {\n    return (a.a > b.a || (a.a == b.a && a.b > b.b));\n  }\n\n  function Fp2Eq(Fp2 memory a, Fp2 memory b) internal pure returns (bool) {\n    return FpEq(a.a, b.a) && FpEq(a.b, b.b);\n  }\n\n  function fp2Gt(Fp2 memory a, Fp2 memory b) internal pure returns (bool) {\n    if (FpEq(a.b, b.b)) {\n      return fpGt(a.a, b.a);\n    } else {\n      return fpGt(a.b, b.b);\n    }\n  }\n\n  function fpAdd2(uint256 a, uint256 b) internal pure returns (Fp memory) {\n    return fpAdd(Fp(0, a), Fp(0, b));\n  }\n\n  function fpAdd3(uint256 a, uint256 b, uint256 c) internal pure returns (Fp memory) {\n    return fpAdd(Fp(0, a), fpAdd(Fp(0, b), Fp(0, c)));\n  }\n\n  function fpAdd4(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (Fp memory) {\n    return fpAdd(Fp(0, a), fpAdd(Fp(0, b), fpAdd(Fp(0, c), Fp(0, d))));\n  }\n\n  function fpAdd(Fp memory a, Fp memory b) internal pure returns (Fp memory) {\n    uint256 bb = a.b + b.b;\n    uint256 aa = a.a + b.a + (bb >= a.b && bb >= b.b ? 0 : 1);\n    return Fp(aa, bb);\n  }\n\n  function fpSub(Fp memory a, Fp memory b) internal pure returns (Fp memory) {\n    Fp memory p = Fp(\n      0x1ae3a4617c510eac63b05c06ca1493b,\n      0x1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001\n    );\n    Fp memory x = fpAdd(a, p);\n    uint256 bb = x.b - b.b;\n    uint256 aa = x.a - b.a - (bb <= x.b ? 0 : 1);\n    return Fp(aa, bb);\n  }\n\n  function fpModExp(Fp memory base, uint256 exponent, Fp memory modulus)\n    internal\n    view\n    returns (Fp memory)\n  {\n    uint256 base1 = base.a;\n    uint256 base2 = base.b;\n    uint256 modulus1 = modulus.a;\n    uint256 modulus2 = modulus.b;\n    bytes memory arg = new bytes(3 * 32 + 32 + 64 + 64);\n    bytes memory ret = new bytes(64);\n    uint256 result1;\n    uint256 result2;\n    assembly {\n      // length of base, exponent, modulus\n      mstore(add(arg, 0x20), 0x40)\n      mstore(add(arg, 0x40), 0x20)\n      mstore(add(arg, 0x60), 0x40)\n\n      // assign base, exponent, modulus\n      mstore(add(arg, 0x80), base1)\n      mstore(add(arg, 0xa0), base2)\n      mstore(add(arg, 0xc0), exponent)\n      mstore(add(arg, 0xe0), modulus1)\n      mstore(add(arg, 0x100), modulus2)\n\n      // call the precompiled contract BigModExp (0x05)\n      let success := staticcall(gas, 0x05, add(arg, 0x20), 0x100, add(ret, 0x20), 0x40)\n      switch success\n        case 0 {\n          revert(0x0, 0x0)\n        }\n        default {\n          result1 := mload(add(0x20, ret))\n          result2 := mload(add(0x40, ret))\n        }\n    }\n    return Fp(result1, result2);\n  }\n\n  function fpModExp2(Fp memory base, uint256 idx, uint256 exponent, Fp memory modulus)\n    internal\n    view\n    returns (Fp memory)\n  {\n    uint256 base1 = base.a;\n    uint256 base2 = base.b;\n    uint256 modulus1 = modulus.a;\n    uint256 modulus2 = modulus.b;\n    bytes memory arg = new bytes(3 * 32 + 62 + 64 + 32 + idx);\n    bytes memory ret = new bytes(64);\n    uint256 result1;\n    uint256 result2;\n    assembly {\n      // length of base, exponent, modulus\n      mstore(add(arg, 0x20), add(0x40, idx))\n      mstore(add(arg, 0x40), 0x20)\n      mstore(add(arg, 0x60), 0x40)\n\n      // assign base, exponent, modulus\n      mstore(add(arg, 0x80), base1)\n      mstore(add(arg, 0xa0), base2)\n      mstore(add(arg, add(idx, 0xc0)), exponent)\n      mstore(add(arg, add(idx, 0xe0)), modulus1)\n      mstore(add(arg, add(idx, 0x100)), modulus2)\n\n      // call the precompiled contract BigModExp (0x05)\n      let success := staticcall(gas, 0x05, add(arg, 0x20), add(idx, 0x100), add(ret, 0x20), 0x40)\n      switch success\n        case 0 {\n          revert(0x0, 0x0)\n        }\n        default {\n          result1 := mload(add(0x20, ret))\n          result2 := mload(add(0x40, ret))\n        }\n    }\n    return Fp(result1, result2);\n  }\n\n  function fpMul(Fp memory a, Fp memory b) internal view returns (Fp memory) {\n    uint256 a1 = uint128(a.b);\n    uint256 a2 = uint128(a.b >> 128);\n    uint256 a3 = uint128(a.a);\n    uint256 a4 = uint128(a.a >> 128);\n    uint256 b1 = uint128(b.b);\n    uint256 b2 = uint128(b.b >> 128);\n    uint256 b3 = uint128(b.a);\n    uint256 b4 = uint128(b.a >> 128);\n    Fp memory res = fpNormal2(Fp(0, a1 * b1), 0);\n    res = fpAdd(res, fpNormal2(fpAdd2(a1 * b2, a2 * b1), 16));\n    res = fpAdd(res, fpNormal2(fpAdd3(a1 * b3, a2 * b2, a3 * b1), 32));\n    res = fpAdd(res, fpNormal2(fpAdd4(a1 * b4, a2 * b3, a3 * b2, a4 * b1), 48));\n    res = fpAdd(res, fpNormal2(fpAdd3(a2 * b4, a3 * b3, a4 * b2), 64));\n    res = fpAdd(res, fpNormal2(fpAdd2(a3 * b4, a4 * b3), 96));\n    res = fpAdd(res, fpNormal2(Fp(0, a4 * b4), 128));\n    return fpNormal(res);\n  }\n\n  function fp2Normal(Fp2 memory a) internal view returns (Fp2 memory) {\n    return Fp2(fpNormal(a.a), fpNormal(a.b));\n  }\n\n  function fp2Add(Fp2 memory a, Fp2 memory b) internal pure returns (Fp2 memory) {\n    return Fp2(fpAdd(a.a, b.a), fpAdd(a.b, b.b));\n  }\n\n  function fp2Mul(Fp2 memory a, Fp2 memory b) internal view returns (Fp2 memory) {\n    Fp memory non_residue = B12.Fp(\n      0x01ae3a4617c510eac63b05c06ca1493b,\n      0x1a22d9f300f5138f1ef3622fba094800170b5d44300000008508bffffffffffc\n    );\n\n    Fp memory v0 = fpMul(a.a, b.a);\n    Fp memory v1 = fpMul(a.b, b.b);\n\n    Fp memory res1 = fpAdd(a.b, a.a);\n    res1 = fpMul(res1, fpAdd(b.a, b.b));\n    res1 = fpSub(res1, v0);\n    res1 = fpSub(res1, v1);\n    Fp memory res0 = fpAdd(v0, fpMul(v1, non_residue));\n    return Fp2(res0, res1);\n  }\n\n  function fpNormal2(Fp memory a, uint256 idx) internal view returns (Fp memory) {\n    Fp memory p = Fp(\n      0x1ae3a4617c510eac63b05c06ca1493b,\n      0x1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001\n    );\n    return fpModExp2(a, idx, 1, p);\n  }\n\n  function fpNormal(Fp memory a) internal view returns (Fp memory) {\n    Fp memory p = Fp(\n      0x1ae3a4617c510eac63b05c06ca1493b,\n      0x1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001\n    );\n    return fpModExp(a, 1, p);\n  }\n\n  function mapToG2(Fp2 memory x, Fp2 memory hint1, Fp2 memory hint2, bool greatest)\n    internal\n    view\n    returns (G2Point memory)\n  {\n    Fp2 memory one = Fp2(Fp(0, 1), Fp(0, 0));\n    Fp2 memory res = fp2Add(fp2Mul(x, fp2Mul(x, x)), one);\n    Fp2 memory sqhint1 = fp2Mul(hint1, hint1);\n    Fp2 memory sqhint2 = fp2Mul(hint2, hint2);\n    require(Fp2Eq(sqhint1, res), \"y1 not sqrt\");\n    require(Fp2Eq(sqhint2, res), \"y2 not sqrt\");\n    require(fp2Gt(hint1, hint2), \"y1 not greatest\");\n    G2Point memory p = G2Point(x, greatest ? hint1 : hint2);\n    return p;\n  }\n\n  function mapToG1(Fp memory x, Fp memory hint1, Fp memory hint2, bool greatest)\n    internal\n    view\n    returns (G1Point memory)\n  {\n    Fp memory base = Fp(\n      0x1ae3a4617c510eac63b05c06ca1493b,\n      0x1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001\n    );\n    Fp memory one = Fp(0, 1);\n    Fp memory res = fpAdd(fpModExp(x, 3, base), one);\n    Fp memory sqhint1 = fpModExp(hint1, 2, base);\n    Fp memory sqhint2 = fpModExp(hint2, 2, base);\n    require(FpEq(sqhint1, res), \"y1 not sqrt\");\n    require(FpEq(sqhint2, res), \"y2 not sqrt\");\n    require(fpGt(hint1, hint2), \"y1 not greatest\");\n    return G1Point(x, greatest ? hint1 : hint2);\n  }\n\n  function parsePointGen(bytes memory h, uint256 offset)\n    internal\n    pure\n    returns (uint256, uint256, uint256)\n  {\n    uint256 a = 0;\n    uint256 b = 0;\n    for (uint256 i = 0; i < 32; i++) {\n      uint256 byt = uint256(uint8(h[offset + i]));\n      b = b + (byt << (i * 8));\n    }\n    for (uint256 i = 0; i < 15; i++) {\n      uint256 byt = uint256(uint8(h[offset + i + 32]));\n      a = a + (byt << (i * 8));\n    }\n    return (a, b, uint256(uint8(h[offset + 47])));\n  }\n\n  function parsePoint(bytes memory h, uint256 offset) internal pure returns (Fp memory, bool) {\n    (uint256 a, uint256 b, uint256 byt) = parsePointGen(h, offset);\n    a = a + ((byt & 0x7f) << (15 * 8));\n    return (Fp(a, b), byt & 0xa0 != 0);\n  }\n\n  function parseSimplePoint(bytes memory h, uint256 offset) internal pure returns (Fp memory) {\n    Fp memory res = Fp(0, 0);\n    parseSimplePoint(h, offset, res);\n    return res;\n  }\n\n  function parseSimplePoint(bytes memory h, uint256 offset, Fp memory p) internal pure {\n    /* (uint256 a, uint256 b, uint256 byt) = parsePointGen(h, offset);\n        a = a + (byt << 15*8); */\n    uint256 a;\n    uint256 b;\n    assembly {\n      a := mload(add(0x20, add(h, offset)))\n      b := mload(add(0x40, add(h, offset)))\n    }\n    // p.a = a & (0xffffffffffffffffffffffffffffffff << (16*8));\n    p.a = a;\n    p.b = b;\n  }\n\n  function parsePoint(bytes memory h) internal pure returns (Fp memory, bool) {\n    return parsePoint(h, 0);\n  }\n\n  function parseRandomPoint(bytes memory h) internal pure returns (Fp memory, bool) {\n    (uint256 a, uint256 b, uint256 byt) = parsePointGen(h, 0);\n    a = a + ((byt & 0x01) << (15 * 8));\n    return (Fp(a, b), byt & 0x02 != 0);\n  }\n\n  function readFp2(bytes memory h, uint256 offset) internal pure returns (Fp2 memory) {\n    Fp memory a = parseSimplePoint(h, offset);\n    Fp memory b = parseSimplePoint(h, 64 + offset);\n    return Fp2(a, b);\n  }\n\n  function readFp2(bytes memory h, uint256 offset, Fp2 memory p) internal pure {\n    parseSimplePoint(h, offset, p.a);\n    parseSimplePoint(h, 64 + offset, p.b);\n  }\n\n  function readG2(bytes memory h, uint256 offset) internal pure returns (G2Point memory) {\n    Fp2 memory a = readFp2(h, offset);\n    Fp2 memory b = readFp2(h, 128 + offset);\n    return G2Point(a, b);\n  }\n\n  function readG2(bytes memory h, uint256 offset, G2Point memory p) internal pure {\n    readFp2(h, offset, p.X);\n    readFp2(h, 128 + offset, p.Y);\n  }\n\n  function g1Eq(G1Point memory a, G1Point memory b) internal pure returns (bool) {\n    return FpEq(a.X, b.X) && FpEq(a.Y, b.Y);\n  }\n\n  function g1Eq(G2Point memory a, G2Point memory b) internal pure returns (bool) {\n    return (Fp2Eq(a.X, b.X) && Fp2Eq(a.Y, b.Y));\n  }\n\n  function parseFp(bytes memory input, uint256 offset) internal pure returns (Fp memory ret) {\n    bytes29 ref = input.ref(0).postfix(input.length - offset, 0);\n\n    ret.a = ref.indexUint(0, 32);\n    ret.b = ref.indexUint(32, 32);\n  }\n\n  function parseFp2(bytes memory input, uint256 offset) internal pure returns (Fp2 memory ret) {\n    bytes29 ref = input.ref(0).postfix(input.length - offset, 0);\n\n    ret.a.a = ref.indexUint(0, 32);\n    ret.a.b = ref.indexUint(32, 32);\n    ret.b.a = ref.indexUint(64, 32);\n    ret.b.b = ref.indexUint(96, 32);\n  }\n\n  function parseCompactFp(bytes memory input, uint256 offset)\n    internal\n    pure\n    returns (Fp memory ret)\n  {\n    bytes29 ref = input.ref(0).postfix(input.length - offset, 0);\n\n    ret.a = ref.indexUint(0, 16);\n    ret.b = ref.indexUint(16, 32);\n  }\n\n  function parseCompactFp2(bytes memory input, uint256 offset)\n    internal\n    pure\n    returns (Fp2 memory ret)\n  {\n    bytes29 ref = input.ref(0).postfix(input.length - offset, 0);\n\n    ret.a.a = ref.indexUint(48, 16);\n    ret.a.b = ref.indexUint(64, 32);\n    ret.b.a = ref.indexUint(0, 16);\n    ret.b.b = ref.indexUint(16, 32);\n  }\n\n  function parseG1(bytes memory input, uint256 offset) internal pure returns (G1Point memory ret) {\n    // unchecked sub is safe due to view validity checks\n    bytes29 ref = input.ref(0).postfix(input.length - offset, 0);\n\n    ret.X.a = ref.indexUint(0, 32);\n    ret.X.b = ref.indexUint(32, 32);\n    ret.Y.a = ref.indexUint(64, 32);\n    ret.Y.b = ref.indexUint(96, 32);\n  }\n\n  function parseG2(bytes memory input, uint256 offset) internal pure returns (G2Point memory ret) {\n    // unchecked sub is safe due to view validity checks\n    bytes29 ref = input.ref(0).postfix(input.length - offset, 0);\n\n    ret.X.a.a = ref.indexUint(0, 32);\n    ret.X.a.b = ref.indexUint(32, 32);\n    ret.X.b.a = ref.indexUint(64, 32);\n    ret.X.b.b = ref.indexUint(96, 32);\n    ret.Y.a.a = ref.indexUint(128, 32);\n    ret.Y.a.b = ref.indexUint(160, 32);\n    ret.Y.b.a = ref.indexUint(192, 32);\n    ret.Y.b.b = ref.indexUint(224, 32);\n  }\n\n  function serializeFp(Fp memory p) internal pure returns (bytes memory) {\n    return abi.encodePacked(p.a, p.b);\n  }\n\n  function serializeFp2(Fp2 memory p) internal pure returns (bytes memory) {\n    return abi.encodePacked(p.a.a, p.a.b, p.b.a, p.b.b);\n  }\n\n  function serializeG1(G1Point memory p) internal pure returns (bytes memory) {\n    return abi.encodePacked(p.X.a, p.X.b, p.Y.a, p.Y.b);\n  }\n\n  function serializeG2(G2Point memory p) internal pure returns (bytes memory) {\n    return abi.encodePacked(p.X.a.a, p.X.a.b, p.X.b.a, p.X.b.b, p.Y.a.a, p.Y.a.b, p.Y.b.a, p.Y.b.b);\n  }\n\n  function g1Add(G1Point memory a, G1Point memory b, uint8 precompile, uint256 gasEstimate)\n    internal\n    view\n    returns (G1Point memory c)\n  {\n    uint256[8] memory input;\n    input[0] = a.X.a;\n    input[1] = a.X.b;\n    input[2] = a.Y.a;\n    input[3] = a.Y.b;\n\n    input[4] = b.X.a;\n    input[5] = b.X.b;\n    input[6] = b.Y.a;\n    input[7] = b.Y.b;\n\n    bool success;\n    assembly {\n      success := staticcall(gasEstimate, precompile, input, 256, input, 128)\n      // deallocate the input, leaving dirty memory\n      mstore(0x40, input)\n    }\n\n    require(success, \"g1 add precompile failed\");\n    c.X.a = input[0];\n    c.X.b = input[1];\n    c.Y.a = input[2];\n    c.Y.b = input[3];\n  }\n\n  // Overwrites A\n  function g1Mul(G1Point memory a, uint256 scalar, uint8 precompile, uint256 gasEstimate)\n    internal\n    view\n    returns (G1Point memory c)\n  {\n    uint256[5] memory input;\n    input[0] = a.X.a;\n    input[1] = a.X.b;\n    input[2] = a.Y.a;\n    input[3] = a.Y.b;\n\n    input[4] = scalar;\n\n    bool success;\n    assembly {\n      success := staticcall(\n        gasEstimate,\n        precompile,\n        input,\n        160,\n        input, // reuse the memory to avoid growing\n        128\n      )\n      // deallocate the input, leaving dirty memory\n      mstore(0x40, input)\n    }\n    require(success, \"g1 mul precompile failed\");\n    c.X.a = input[0];\n    c.X.b = input[1];\n    c.Y.a = input[2];\n    c.Y.b = input[3];\n  }\n\n  function g1MultiExp(G1MultiExpArg[] memory argVec, uint8 precompile, uint256 gasEstimate)\n    internal\n    view\n    returns (G1Point memory c)\n  {\n    uint256[] memory input = new uint256[](argVec.length * 5);\n    // hate this\n    for (uint256 i = 0; i < argVec.length; i++) {\n      input[i * 5 + 0] = argVec[i].point.X.a;\n      input[i * 5 + 1] = argVec[i].point.X.b;\n      input[i * 5 + 2] = argVec[i].point.Y.a;\n      input[i * 5 + 3] = argVec[i].point.Y.b;\n      input[i * 5 + 4] = argVec[i].scalar;\n    }\n\n    bool success;\n    assembly {\n      success := staticcall(\n        gasEstimate,\n        precompile,\n        add(input, 0x20),\n        mul(mload(input), 0x20),\n        add(input, 0x20),\n        128\n      )\n      // deallocate the input, leaving dirty memory\n      mstore(0x40, input)\n    }\n    require(success, \"g1 multiExp precompile failed\");\n    c.X.a = input[0];\n    c.X.b = input[1];\n    c.Y.a = input[2];\n    c.Y.b = input[3];\n  }\n\n  function g2Add(G2Point memory a, G2Point memory b, uint8 precompile, uint256 gasEstimate)\n    internal\n    view\n    returns (G2Point memory c)\n  {\n    uint256[16] memory input;\n    input[0] = a.X.a.a;\n    input[1] = a.X.a.b;\n    input[2] = a.X.b.a;\n    input[3] = a.X.b.b;\n\n    input[4] = a.Y.a.a;\n    input[5] = a.Y.a.b;\n    input[6] = a.Y.b.a;\n    input[7] = a.Y.b.b;\n\n    input[8] = b.X.a.a;\n    input[9] = b.X.a.b;\n    input[10] = b.X.b.a;\n    input[11] = b.X.b.b;\n\n    input[12] = b.Y.a.a;\n    input[13] = b.Y.a.b;\n    input[14] = b.Y.b.a;\n    input[15] = b.Y.b.b;\n\n    bool success;\n    assembly {\n      success := staticcall(\n        gasEstimate,\n        precompile,\n        input,\n        512,\n        input, // reuse the memory to avoid growing\n        256\n      )\n      // deallocate the input, leaving dirty memory\n      mstore(0x40, input)\n    }\n    require(success, \"g2 add precompile failed\");\n    c.X.a.a = input[0];\n    c.X.a.b = input[1];\n    c.X.b.a = input[2];\n    c.X.b.b = input[3];\n\n    c.Y.a.a = input[4];\n    c.Y.a.b = input[5];\n    c.Y.b.a = input[6];\n    c.Y.b.b = input[7];\n  }\n\n  // Overwrites A\n  function g2Mul(G2Point memory a, uint256 scalar, uint8 precompile, uint256 gasEstimate)\n    internal\n    view\n  {\n    uint256[9] memory input;\n\n    input[0] = a.X.a.a;\n    input[1] = a.X.a.b;\n    input[2] = a.X.b.a;\n    input[3] = a.X.b.b;\n\n    input[4] = a.Y.a.a;\n    input[5] = a.Y.a.b;\n    input[6] = a.Y.b.a;\n    input[7] = a.Y.b.b;\n\n    input[8] = scalar;\n\n    bool success;\n    assembly {\n      success := staticcall(\n        gasEstimate,\n        precompile,\n        input,\n        288,\n        input, // reuse the memory to avoid growing\n        256\n      )\n      // deallocate the input, leaving dirty memory\n      mstore(0x40, input)\n    }\n    require(success, \"g2 mul precompile failed\");\n    a.X.a.a = input[0];\n    a.X.a.b = input[1];\n    a.X.b.a = input[2];\n    a.X.b.b = input[3];\n    a.Y.a.a = input[4];\n    a.Y.a.b = input[5];\n    a.Y.b.a = input[6];\n    a.Y.b.b = input[7];\n  }\n\n  function g2MultiExp(G2MultiExpArg[] memory argVec, uint8 precompile, uint256 gasEstimate)\n    internal\n    view\n    returns (G2Point memory c)\n  {\n    uint256[] memory input = new uint256[](argVec.length * 9);\n    // hate this\n    for (uint256 i = 0; i < input.length / 9; i += 1) {\n      uint256 idx = i * 9;\n      input[idx + 0] = argVec[i].point.X.a.a;\n      input[idx + 1] = argVec[i].point.X.a.b;\n      input[idx + 2] = argVec[i].point.X.b.a;\n      input[idx + 3] = argVec[i].point.X.b.b;\n      input[idx + 4] = argVec[i].point.Y.a.a;\n      input[idx + 5] = argVec[i].point.Y.a.b;\n      input[idx + 6] = argVec[i].point.Y.b.a;\n      input[idx + 7] = argVec[i].point.Y.b.b;\n      input[idx + 8] = argVec[i].scalar;\n    }\n\n    bool success;\n    assembly {\n      success := staticcall(\n        gasEstimate,\n        precompile,\n        add(input, 0x20),\n        mul(mload(input), 0x20), // 288 bytes per arg\n        add(input, 0x20), // write directly to the already allocated result\n        256\n      )\n      // deallocate the input, leaving dirty memory\n      mstore(0x40, input)\n    }\n    require(success, \"g2 multiExp precompile failed\");\n    c.X.a.a = input[0];\n    c.X.a.b = input[1];\n    c.X.b.a = input[2];\n    c.X.b.b = input[3];\n    c.Y.a.a = input[4];\n    c.Y.a.b = input[5];\n    c.Y.b.a = input[6];\n    c.Y.b.b = input[7];\n  }\n\n  function pairing(PairingArg[] memory argVec, uint8 precompile, uint256 gasEstimate)\n    internal\n    view\n    returns (bool result)\n  {\n    uint256 len = argVec.length;\n    uint256[] memory input = new uint256[](len * 12);\n\n    for (uint256 i = 0; i < len; i++) {\n      uint256 idx = i * 12;\n      input[idx + 0] = argVec[i].g1.X.a;\n      input[idx + 1] = argVec[i].g1.X.b;\n      input[idx + 2] = argVec[i].g1.Y.a;\n      input[idx + 3] = argVec[i].g1.Y.b;\n      input[idx + 4] = argVec[i].g2.X.a.a;\n      input[idx + 5] = argVec[i].g2.X.a.b;\n      input[idx + 6] = argVec[i].g2.X.b.a;\n      input[idx + 7] = argVec[i].g2.X.b.b;\n      input[idx + 8] = argVec[i].g2.Y.a.a;\n      input[idx + 9] = argVec[i].g2.Y.a.b;\n      input[idx + 10] = argVec[i].g2.Y.b.a;\n      input[idx + 11] = argVec[i].g2.Y.b.b;\n    }\n\n    bool success;\n    assembly {\n      success := staticcall(\n        gasEstimate,\n        precompile,\n        add(input, 0x20), // the body of the array\n        mul(384, len), // 384 bytes per arg\n        mload(0x40), // write to earliest freemem\n        32\n      )\n      result := mload(mload(0x40)) // load what we just wrote\n      // deallocate the input, leaving dirty memory\n      mstore(0x40, input)\n    }\n    require(success, \"pairing precompile failed\");\n  }\n}\n\nlibrary B12_381Lib {\n  using B12 for B12.G1Point;\n  using B12 for B12.G2Point;\n\n  uint8 constant G1_ADD = 10;\n  uint8 constant G1_MUL = 11;\n  uint8 constant G1_MULTI_EXP = 12;\n  uint8 constant G2_ADD = 13;\n  uint8 constant G2_MUL = 14;\n  uint8 constant G2_MULTI_EXP = 15;\n  uint8 constant PAIRING = 16;\n  uint8 constant MAP_TO_G1 = 17;\n  uint8 constant MAP_TO_G2 = 18;\n\n  function negativeP1() internal pure returns (B12.G1Point memory p) {\n    p.X.a = 31827880280837800241567138048534752271;\n    p.X.b = 88385725958748408079899006800036250932223001591707578097800747617502997169851;\n    p.Y.a = 22997279242622214937712647648895181298;\n    p.Y.b = 46816884707101390882112958134453447585552332943769894357249934112654335001290;\n  }\n\n  function mapToG1(B12.Fp memory a) internal view returns (B12.G1Point memory b) {\n    uint256[2] memory input;\n    input[0] = a.a;\n    input[1] = a.b;\n\n    bool success;\n    uint8 ADDR = MAP_TO_G1;\n    assembly {\n      success := staticcall(\n        20000,\n        ADDR,\n        input, // the body of the array\n        64,\n        b, // write directly to pre-allocated result\n        128\n      )\n      // deallocate the input\n      mstore(add(input, 0), 0)\n      mstore(add(input, 0x20), 0)\n      mstore(0x40, input)\n    }\n  }\n\n  function mapToG2(B12.Fp2 memory a) internal view returns (B12.G2Point memory b) {\n    uint256[4] memory input;\n    input[0] = a.a.a;\n    input[1] = a.a.b;\n    input[2] = a.b.a;\n    input[3] = a.b.b;\n\n    bool success;\n    uint8 ADDR = MAP_TO_G2;\n    assembly {\n      success := staticcall(\n        120000,\n        ADDR,\n        input, // the body of the array\n        128,\n        b, // write directly to pre-allocated result\n        256\n      )\n      // deallocate the input\n      mstore(add(input, 0), 0)\n      mstore(add(input, 0x20), 0)\n      mstore(add(input, 0x40), 0)\n      mstore(add(input, 0x60), 0)\n      mstore(0x40, input)\n    }\n  }\n\n  function g1Add(B12.G1Point memory a, B12.G1Point memory b)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    return a.g1Add(b, G1_ADD, 15000);\n  }\n\n  function g1Mul(B12.G1Point memory a, uint256 scalar)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    return a.g1Mul(scalar, G1_MUL, 50000);\n  }\n\n  function g1MultiExp(B12.G1MultiExpArg[] memory argVec)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    uint256 roughCost = (argVec.length * 12000 * 1200) / 1000;\n    return B12.g1MultiExp(argVec, G1_MULTI_EXP, roughCost);\n  }\n\n  function g2Add(B12.G2Point memory a, B12.G2Point memory b)\n    internal\n    view\n    returns (B12.G2Point memory c)\n  {\n    return a.g2Add(b, G2_ADD, 20000);\n  }\n\n  function g2Mul(B12.G2Point memory a, uint256 scalar) internal view {\n    return a.g2Mul(scalar, G2_MUL, 60000);\n  }\n\n  function g2MultiExp(B12.G2MultiExpArg[] memory argVec)\n    internal\n    view\n    returns (B12.G2Point memory c)\n  {\n    uint256 roughCost = (argVec.length * 55000 * 1200) / 1000;\n    return B12.g2MultiExp(argVec, G2_MULTI_EXP, roughCost);\n  }\n\n  function pairing(B12.PairingArg[] memory argVec) internal view returns (bool result) {\n    uint256 roughCost = (23000 * argVec.length) + 115000;\n    return B12.pairing(argVec, PAIRING, roughCost);\n  }\n}\n\nlibrary B12_377Lib {\n  using B12 for B12.G1Point;\n  using B12 for B12.G2Point;\n\n  uint8 constant G1_ADD = 19;\n  uint8 constant G1_MUL = 20;\n  uint8 constant G1_MULTI_EXP = 21;\n  uint8 constant G2_ADD = 22;\n  uint8 constant G2_MUL = 23;\n  uint8 constant G2_MULTI_EXP = 24;\n  uint8 constant PAIRING = 25;\n\n  function g1Add(B12.G1Point memory a, B12.G1Point memory b)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    return a.g1Add(b, G1_ADD, 15000);\n  }\n\n  function g1Mul(B12.G1Point memory a, uint256 scalar)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    return a.g1Mul(scalar, G1_MUL, 50000);\n  }\n\n  function g1MultiExp(B12.G1MultiExpArg[] memory argVec)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    uint256 roughCost = (argVec.length * 12000 * 1200) / 1000;\n    return B12.g1MultiExp(argVec, G1_MULTI_EXP, roughCost);\n  }\n\n  function g2Add(B12.G2Point memory a, B12.G2Point memory b)\n    internal\n    view\n    returns (B12.G2Point memory c)\n  {\n    return a.g2Add(b, G2_ADD, 20000);\n  }\n\n  function g2Mul(B12.G2Point memory a, uint256 scalar) internal view {\n    return a.g2Mul(scalar, G2_MUL, 60000);\n  }\n\n  function g2MultiExp(B12.G2MultiExpArg[] memory argVec)\n    internal\n    view\n    returns (B12.G2Point memory c)\n  {\n    uint256 roughCost = (argVec.length * 55000 * 1200) / 1000;\n    return B12.g2MultiExp(argVec, G2_MULTI_EXP, roughCost);\n  }\n\n  function pairing(B12.PairingArg[] memory argVec) internal view returns (bool result) {\n    uint256 roughCost = (55000 * argVec.length) + 65000;\n    return B12.pairing(argVec, PAIRING, roughCost);\n  }\n}\n\nlibrary CeloB12_377Lib {\n  using B12 for B12.G1Point;\n  using B12 for B12.G2Point;\n\n  uint8 constant G1_ADD = 0xf2;\n  uint8 constant G1_MUL = 0xf1;\n  uint8 constant G1_MULTI_EXP = 0xf0;\n  uint8 constant G2_ADD = 0xef;\n  uint8 constant G2_MUL = 0xee;\n  uint8 constant G2_MULTI_EXP = 0xed;\n  uint8 constant PAIRING = 0xec;\n\n  function g1Add(B12.G1Point memory a, B12.G1Point memory b)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    return a.g1Add(b, G1_ADD, 15000);\n  }\n\n  function g1Mul(B12.G1Point memory a, uint256 scalar)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    return a.g1Mul(scalar, G1_MUL, 50000);\n  }\n\n  function g1MultiExp(B12.G1MultiExpArg[] memory argVec)\n    internal\n    view\n    returns (B12.G1Point memory c)\n  {\n    uint256 roughCost = (argVec.length * 12000 * 1200) / 1000;\n    return B12.g1MultiExp(argVec, G1_MULTI_EXP, roughCost);\n  }\n\n  function g2Add(B12.G2Point memory a, B12.G2Point memory b)\n    internal\n    view\n    returns (B12.G2Point memory c)\n  {\n    return a.g2Add(b, G2_ADD, 20000);\n  }\n\n  function g2Mul(B12.G2Point memory a, uint256 scalar) internal view {\n    return a.g2Mul(scalar, G2_MUL, 60000);\n  }\n\n  function g2MultiExp(B12.G2MultiExpArg[] memory argVec)\n    internal\n    view\n    returns (B12.G2Point memory c)\n  {\n    uint256 roughCost = (argVec.length * 55000 * 1200) / 1000;\n    return B12.g2MultiExp(argVec, G2_MULTI_EXP, roughCost);\n  }\n\n  function pairing(B12.PairingArg[] memory argVec) internal view returns (bool result) {\n    uint256 roughCost = (55000 * argVec.length) + 65000;\n    return B12.pairing(argVec, PAIRING, roughCost);\n  }\n}\n"
    },
    "@summa-tx/memview.sol/contracts/TypedMemView.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.5.10;\n\nimport {SafeMath} from \"./SafeMath.sol\";\n\nlibrary TypedMemView {\n    using SafeMath for uint256;\n\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    // Returns the encoded hex charcter that represents the lower 4 bits of the argument.\n    function nibbleHex(uint8 _b) internal pure returns (uint8) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {return 0x30;} // 0\n        if (_nibble == 0xf1) {return 0x31;} // 1\n        if (_nibble == 0xf2) {return 0x32;} // 2\n        if (_nibble == 0xf3) {return 0x33;} // 3\n        if (_nibble == 0xf4) {return 0x34;} // 4\n        if (_nibble == 0xf5) {return 0x35;} // 5\n        if (_nibble == 0xf6) {return 0x36;} // 6\n        if (_nibble == 0xf7) {return 0x37;} // 7\n        if (_nibble == 0xf8) {return 0x38;} // 8\n        if (_nibble == 0xf9) {return 0x39;} // 9\n        if (_nibble == 0xfa) {return 0x61;} // a\n        if (_nibble == 0xfb) {return 0x62;} // b\n        if (_nibble == 0xfc) {return 0x63;} // c\n        if (_nibble == 0xfd) {return 0x64;} // d\n        if (_nibble == 0xfe) {return 0x65;} // e\n        if (_nibble == 0xff) {return 0x66;} // f\n    }\n\n    // Returns a uint16 containing the hex-encoded byte\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\n        encoded <<= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    // Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n    // `second` contains the encoded lower 16 bytes.\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i > 15; i -= 1) {\n            uint8 _byte = uint8(_b >> (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first <<= 16;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i < 255 ; i -= 1) {\n            uint8 _byte = uint8(_b >> (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second <<= 16;\n            }\n        }\n    }\n\n    /// @notice          Changes the endianness of a uint256\n    /// @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n    /// @param _b        The unsigned integer to reverse\n    /// @return          v - The reversed value\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        // swap 8-byte long pairs\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    /// Create a mask with the highest `_len` bits set\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /// Return the null view\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /// Check if the view is null\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /// Check if the view is not null\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /// Check if the view is of a valid type and points to a valid location in\n    /// memory. We perform this check by examining solidity's unallocated\n    /// memory pointer and ensuring that the view's upper bound is less than\n    /// that.\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {return false;}\n        uint256 _end = end(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /// Require that a typed memory view be valid.\n    /// Returns the view for easy chaining\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /// Return true if the memview is of the expected type. Otherwise false.\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /// Require that a typed memory view has a specific type.\n    /// Returns the view for easy chaining\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /// Return an identical view with a different type\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /// Unsafe raw pointer construction. This should generally not be called\n    /// directly. Prefer `ref` wherever possible.\n    function buildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc))  // insert loc\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\n        }\n    }\n\n    /// Instantiate a new memory view. This should generally not be called\n    /// directly. Prefer `ref` wherever possible.\n    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc.add(_len);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = buildUnchecked(_type, _loc, _len);\n    }\n\n    /// Instantiate a memory view from a byte array.\n    ///\n    /// Note that due to Solidity memory representation, it is not possible to\n    /// implement a deref, as the `bytes` type stores its len in memory.\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /// Return the associated type information\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /// Optimized type comparison. Checks that the 5-byte type flag is equal.\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\n    }\n\n    /// Return the memory address of the underlying bytes\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /// The number of memory words this memory view occupies, rounded up\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return uint256(len(memView)).add(32) / 32;\n    }\n\n    /// The in-memory footprint of a fresh copy of the view\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /// The number of bytes of the view\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /// Returns the endpoint of the `memView`\n    function end(bytes29 memView) internal pure returns (uint256) {\n        return loc(memView) + len(memView);\n    }\n\n    /// Safe slicing without memory modification.\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc.add(_index).add(_len) > end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc.add(_index);\n        return build(newType, _loc, _len);\n    }\n\n    /// Shortcut to `slice`. Gets a view representing the first `_len` bytes\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /// Shortcut to `slice`. Gets a view representing the last `_len` byte\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\n    }\n\n    /// Construct an error message for an indexing overrun.\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /// Load up to 32 bytes from the view onto the stack.\n    ///\n    /// Returns a bytes32 with only the `_bytes` highest bytes set.\n    /// This can be immediately cast to a smaller fixed-length byte array.\n    /// To automatically cast to an integer, use `indexUint` or `indexInt`.\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {return bytes32(0);}\n        if (_index.add(_bytes) > len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes <= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength = _bytes * 8;\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /// Parse an unsigned integer from the view at `_index`. Requires that the\n    /// view have >= `_bytes` bytes following that index.\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n    }\n\n    /// Parse an unsigned integer from LE bytes.\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /// Parse a signed integer from the view at `_index`. Requires that the\n    /// view have >= `_bytes` bytes following that index.\n    function indexInt(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (int256 result) {\n        return int256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n    }\n\n    /// Parse an address from the view at `_index`. Requires that the view have >= 20 bytes following that index.\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexInt(memView, _index, 20)));\n    }\n\n    /// Return the keccak256 hash of the underlying memory\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /// Return the sha2 digest of the underlying memory. We explicitly deallocate memory afterwards\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n    /// @param memView   The pre-image\n    /// @return          digest - the Digest\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @param memView   A view of the preimage\n    /// @return          digest - the Digest\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /// Return true if the underlying memory is equal. Else false.\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /// Return false if the underlying memory is equal. Else true.\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /// Typed equality. Shortcuts if the pointers are identical, otherwise\n    /// compares type and digest\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\n    }\n\n    /// Typed inequality. Shortcuts if the pointers are identical, otherwise\n    /// compares type and digest\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /// Copy the view to a location, return an unsafe memory reference\n    ///\n    /// Super Dangerous direct memory access.\n    /// This reference can be overwritten if anything else modifies memory (!!!).\n    /// As such it MUST be consumed IMMEDIATELY.\n    /// This function is private to prevent unsafe usage by callers\n    function copyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = buildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /// Copies the referenced memory to a new loc in memory, returning a\n    /// `bytes` pointing to the new memory\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        copyTo(memView, ptr + 0x20);\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /// Join the views in memory, return an unsafe reference to the memory.\n    ///\n    /// Super Dangerous direct memory access.\n    /// This reference can be overwritten if anything else modifies memory (!!!).\n    /// As such it MUST be consumed IMMEDIATELY.\n    /// This function is private to prevent unsafe usage by callers\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i < memViews.length; i ++) {\n            bytes29 memView = memViews[i];\n            copyTo(memView, _location + _offset);\n            _offset += len(memView);\n        }\n        unsafeView = buildUnchecked(0, _location, _offset);\n    }\n\n    /// Produce the keccak256 digest of the concatenated contents of multiple views\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /// Produce the sha256 digest of the concatenated contents of multiple views\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /// copies all views, joins them into a new bytearray\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solium-disable-previous-line security/no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n"
    },
    "@summa-tx/memview.sol/contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.10;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        c = _a * _b;\n        require(c / _a == _b, \"Overflow during multiplication.\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // assert(_b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"Underflow during subtraction.\");\n        return _a - _b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        c = _a + _b;\n        require(c >= _a, \"Overflow during addition.\");\n        return c;\n    }\n}\n"
    },
    "contracts/TestSlasher.sol": {
      "content": "//SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.5.10;\n\nimport {SnarkEpochDataSlasher} from \"@celo/protocol/contracts/governance/SnarkEpochDataSlasher.sol\";\n\nimport {CeloB12_377Lib} from \"@celo/protocol/contracts/common/libraries/B12.sol\";\nimport {B12} from \"@celo/protocol/contracts/common/libraries/B12.sol\";\nimport {CIP20Lib} from \"@celo/protocol/contracts/common/libraries/CIP20Lib.sol\";\nimport {TypedMemView} from \"@summa-tx/memview.sol/contracts/TypedMemView.sol\";\n\ncontract TestSlasher is SnarkEpochDataSlasher {\n\n    constructor() public {}\n\n    function getEpochFromData(bytes memory data) public pure returns (uint256) {\n      return epochFromExtraData(decodeDataArg(data).extra);\n    }\n\n    function testConfig() public pure returns (bytes32) {\n        return CIP20Lib.createConfig(32 /* digest size */, 0, 0, 0, 32 /* leaf length */, 0, 64 /* xof digest length*/, 0, 32 /* inner length */, bytes8(0), \"ULforxof\");\n    }\n\n    function testHash(bytes memory data) public view returns (bytes memory) {\n        return doHash(data);\n    }\n\n    function testBLSPublicKey(uint16 epoch, uint i) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        B12.G2Point memory p = getBLSPublicKey(epoch, i);\n        return (p.X.a.a, p.X.a.b, p.X.b.a, p.X.b.b, p.Y.a.a, p.Y.a.b, p.Y.b.a, p.Y.b.b);\n    }\n\n    function testParseG1(bytes memory data) public pure returns (uint256, uint256, uint256, uint256) {\n        B12.G1Point memory p = B12.parseG1(data, 0);\n        return (p.X.a, p.X.b, p.Y.a, p.Y.b);\n    }\n\n    function testHashing(bytes memory extra, bytes memory message) public view returns (uint16, bytes memory, bytes memory) {\n        return (epochFromExtraData(extra), doHash(abi.encodePacked(extra, message)), abi.encodePacked(extra, message));\n    }\n\n    function testAggregation(bytes memory sig0, bytes memory sig1, bytes memory sig2) public view returns (uint256, uint256, uint256, uint256) {\n        B12.G1Point memory sig0_point = B12.parseG1(sig0, 0);\n        B12.G1Point memory sig1_point = B12.parseG1(sig1, 0);\n        B12.G1Point memory sig2_point = B12.parseG1(sig2, 0);\n        B12.G1Point memory res = CeloB12_377Lib.g1Add(CeloB12_377Lib.g1Add(sig0_point, sig1_point), sig2_point);\n        return (res.X.a, res.X.b, res.Y.a, res.Y.b);\n    }\n\n    function testKeyAggregation(bytes memory sig0, bytes memory sig1, bytes memory sig2) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        B12.G2Point memory p0 = B12.readG2(sig0, 0);\n        B12.G2Point memory p1 = B12.readG2(sig1, 0);\n        B12.G2Point memory p2 = B12.readG2(sig2, 0);\n        B12.G2Point memory p = CeloB12_377Lib.g2Add(p0, CeloB12_377Lib.g2Add(p1, p2));\n        return (p.X.a.a, p.X.a.b, p.X.b.a, p.X.b.b, p.Y.a.a, p.Y.a.b, p.Y.b.a, p.Y.b.b);\n    }\n\n    function testParseToG1Scaled(bytes memory extra, bytes memory message, bytes memory hints) public view returns (uint256, uint256, uint256, uint256) {\n        B12.G1Point memory p = parseToG1Scaled(doHash(abi.encodePacked(extra, message)), hints);\n        return (p.X.a, p.X.b, p.Y.a, p.Y.b);\n    }\n\n    function testParseToRandom(bytes memory extra, bytes memory message) public view returns (uint256, uint256, bool) {\n        bool greatest;\n        B12.Fp memory x;\n        (x, greatest) = B12.parseRandomPoint(doHash(abi.encodePacked(extra, message)));\n        return (x.a, x.b, greatest);\n    }\n\n    function testValid(bytes memory extra, bytes memory message, bytes memory sig, bytes memory hints) public view returns (bool) {\n        B12.G1Point memory p = parseToG1Scaled(doHash(abi.encodePacked(extra, message)), hints);\n        B12.G2Point memory public_key = getBLSPublicKey(100, 0);\n        B12.G1Point memory sig_point = B12.parseG1(sig, 0);\n        B12.PairingArg[] memory args = new B12.PairingArg[](2);\n        args[0] = B12.PairingArg(sig_point, negativeP2());\n        args[1] = B12.PairingArg(p, public_key);\n        return CeloB12_377Lib.pairing(args);\n    }\n\n    function testDecode(bytes memory data) public pure returns (bytes memory, bytes memory, uint256, bytes memory, bytes memory) {\n        DataArg memory arg = decodeDataArg(data);\n        return (arg.extra, arg.bhhash, arg.bitmap, arg.sig, arg.hint);\n    }\n\n}\n"
    },
    "@celo/protocol/contracts/governance/SnarkEpochDataSlasher.sol": {
      "content": "//SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.5.8;\n\nimport { TypedMemView } from \"@summa-tx/memview.sol/contracts/TypedMemView.sol\";\n\nimport { CIP20Lib } from \"../common/libraries/CIP20Lib.sol\";\nimport { CeloB12_377Lib } from \"../common/libraries/B12.sol\";\nimport { B12 } from \"../common/libraries/B12.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\n\nimport \"./SlasherUtil.sol\";\n\ncontract SnarkEpochDataSlasher is ICeloVersionedContract, SlasherUtil {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // For each signer address, check if a block header has already been slashed\n  mapping(address => mapping(bytes32 => bool)) isSlashed;\n\n  event SnarkEpochDataSlashPerformed(address indexed validator, uint256 indexed blockNumber);\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 1, 0);\n  }\n\n  function initialize(address registryAddress, uint256 _penalty, uint256 _reward)\n    external\n    initializer\n  {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setSlashingIncentives(_penalty, _reward);\n  }\n\n  function reverse(uint8 a) internal pure returns (uint8) {\n    uint8 res = 0;\n    for (uint8 i = 0; i < 8; i++) {\n      res = res | ((a & 1) << (7 - i));\n      a = a >> 1;\n    }\n    return res;\n  }\n\n  function epochFromExtraData(bytes memory extra) internal pure returns (uint16) {\n    uint8 b1 = uint8(extra[extra.length - 1]);\n    uint8 b2 = uint8(extra[extra.length - 2]);\n    return uint16(reverse(b2)) * 256 + uint16(reverse(b1));\n  }\n\n  function getBlockNumberFromData(bytes memory data) public view returns (uint256) {\n    uint16 epoch = epochFromExtraData(decodeDataArg(data).extra);\n    return getEpochLastBlock(epoch);\n  }\n\n  function checkIfAlreadySlashed(address signer, bytes memory header) internal {\n    bytes32 bhash = keccak256(header);\n    require(!isSlashed[signer][bhash], \"Already slashed\");\n    isSlashed[signer][bhash] = true;\n  }\n\n  function extract(bytes memory a, uint256 offset, uint256 len)\n    internal\n    pure\n    returns (bytes memory)\n  {\n    bytes memory res = new bytes(len);\n    for (uint256 i = 0; i < len; i++) {\n      res[i] = a[i + offset];\n    }\n    return res;\n  }\n\n  struct DataArg {\n    bytes extra;\n    bytes bhhash;\n    uint256 bitmap;\n    bytes sig;\n    bytes hint;\n  }\n\n  function decodeDataArg(bytes memory a) internal pure returns (DataArg memory) {\n    return\n      DataArg(\n        extract(a, 0, 8),\n        extract(a, 8, 48),\n        getUint256FromBytes(a, 56),\n        extract(a, 88, 128),\n        extract(a, 216, 128)\n      );\n  }\n\n  function slash(\n    address signer,\n    uint256 index,\n    bytes memory arg1,\n    bytes memory arg2,\n    uint256 groupMembershipHistoryIndex,\n    address[] memory validatorElectionLessers,\n    address[] memory validatorElectionGreaters,\n    uint256[] memory validatorElectionIndices,\n    address[] memory groupElectionLessers,\n    address[] memory groupElectionGreaters,\n    uint256[] memory groupElectionIndices\n  ) public {\n    slash0(\n      signer,\n      index,\n      decodeDataArg(arg1),\n      decodeDataArg(arg2),\n      groupMembershipHistoryIndex,\n      validatorElectionLessers,\n      validatorElectionGreaters,\n      validatorElectionIndices,\n      groupElectionLessers,\n      groupElectionGreaters,\n      groupElectionIndices\n    );\n  }\n\n  function checkSigner(address signer, uint256 index, uint256 blockNumber) internal view {\n    require(index < numberValidatorsInSet(blockNumber), \"Bad validator index\");\n    require(\n      signer == validatorSignerAddressFromSet(index, blockNumber),\n      \"Wasn't a signer with given index\"\n    );\n  }\n\n  function checkBitmap(uint256 idx, uint256 bitmap) internal pure {\n    require((1 << idx) & bitmap != 0, \"Signer not in bitmap\");\n  }\n\n  function slash0(\n    address signer,\n    uint256 index,\n    DataArg memory arg1,\n    DataArg memory arg2,\n    uint256 groupMembershipHistoryIndex,\n    address[] memory validatorElectionLessers,\n    address[] memory validatorElectionGreaters,\n    uint256[] memory validatorElectionIndices,\n    address[] memory groupElectionLessers,\n    address[] memory groupElectionGreaters,\n    uint256[] memory groupElectionIndices\n  ) internal {\n    checkIfAlreadySlashed(signer, abi.encodePacked(arg1.extra, arg1.bhhash));\n    checkIfAlreadySlashed(signer, abi.encodePacked(arg2.extra, arg2.bhhash));\n    checkBitmap(index, arg1.bitmap);\n    checkBitmap(index, arg2.bitmap);\n    uint256 blockNumber = checkSlash0(arg1, arg2);\n    checkSigner(signer, index, blockNumber);\n    address validator = getAccounts().signerToAccount(signer);\n    performSlashing(\n      validator,\n      msg.sender,\n      blockNumber,\n      groupMembershipHistoryIndex,\n      validatorElectionLessers,\n      validatorElectionGreaters,\n      validatorElectionIndices,\n      groupElectionLessers,\n      groupElectionGreaters,\n      groupElectionIndices\n    );\n    emit SnarkEpochDataSlashPerformed(validator, blockNumber);\n  }\n\n  function checkSlash(bytes memory arg1, bytes memory arg2) public view returns (uint256) {\n    return checkSlash0(decodeDataArg(arg1), decodeDataArg(arg2));\n  }\n\n  function checkSlash0(DataArg memory arg1, DataArg memory arg2) internal view returns (uint256) {\n    uint16 epoch1 = epochFromExtraData(arg1.extra);\n    uint16 epoch2 = epochFromExtraData(arg2.extra);\n    require(epoch1 == epoch2, \"Not on same epoch\");\n    checkSlash1(epoch1, arg1);\n    checkSlash1(epoch1, arg2);\n    return getEpochLastBlock(epoch1); // check which epoch is in the data\n  }\n\n  function checkSlash1(uint16 epoch, DataArg memory arg) internal view {\n    bytes memory data = abi.encodePacked(arg.extra, arg.bhhash);\n    require(isValid(epoch, data, arg.bitmap, arg.sig, arg.hint), \"was not valid signature\");\n  }\n\n  function negativeP2() internal pure returns (B12.G2Point memory) {\n    B12.Fp2 memory x = B12.Fp2(\n      B12.Fp(\n        0x018480be71c785fec89630a2a3841d01,\n        0xc565f071203e50317ea501f557db6b9b71889f52bb53540274e3e48f7c005196\n      ),\n      B12.Fp(\n        0x00ea6040e700403170dc5a51b1b140d5,\n        0x532777ee6651cecbe7223ece0799c9de5cf89984bff76fe6b26bfefa6ea16afe\n      )\n    );\n    B12.Fp2 memory y = B12.Fp2(\n      B12.Fp(\n        0x01452cdfba80a16eecda9254a0ee5986,\n        0x3c1eec808c4079363a9a9facc1d675fb243bd4bbc27383d19474b6bbf602b222\n      ),\n      B12.Fp(\n        0x00b623a64541bbd227e6681d5786d890,\n        0xb833c846c39bf79dfa8fb214eb26433dd491a504d1add8f4ab66f22e7a14706e\n      )\n    );\n    return B12.G2Point(x, y);\n  }\n\n  function mapToG1Scaled(B12.Fp memory x, B12.Fp memory hint1, B12.Fp memory hint2, bool greatest)\n    internal\n    view\n    returns (B12.G1Point memory)\n  {\n    B12.G1Point memory p = B12.mapToG1(x, hint1, hint2, greatest);\n    B12.G1Point memory q = CeloB12_377Lib.g1Mul(p, 30631250834960419227450344600217059328);\n    // The point at infinity is represented as (0,0)\n    require(!(q.X.a == 0 && q.X.b == 0 && q.Y.a == 0 && q.Y.b == 0), \"Point q cannot be zero\");\n    return q;\n  }\n\n  function validatorBLSPublicKeyFromSetInPlace(uint256 index, uint256 blockNumber, bytes memory buffer)\n    public\n    view\n  {\n    bool success;\n    assembly {\n      mstore(add(0x20, buffer), index)\n      mstore(add(0x40, buffer), blockNumber)\n      success := staticcall(\n        gas,\n        235, /* 0xff - 20 */\n        add(0x20, buffer),\n        64,\n        add(0x20, buffer),\n        256\n      )\n    }\n    require(success, \"error calling validatorBLSPublicKeyFromSet precompile\");\n  }\n\n  function getBLSPublicKeyInplace(\n    uint256 blockNumber,\n    uint256 i,\n    B12.G2Point memory p,\n    bytes memory buffer\n  ) internal view {\n    validatorBLSPublicKeyFromSetInPlace(i, blockNumber, buffer);\n    B12.readG2(buffer, 0, p);\n  }\n\n  function getBLSPublicKey(uint256 blockNumber, uint256 i)\n    internal\n    view\n    returns (B12.G2Point memory)\n  {\n    bytes memory data = validatorBLSPublicKeyFromSet(i, blockNumber);\n    return B12.readG2(data, 0);\n  }\n\n  function doHash(bytes memory data) internal view returns (bytes memory) {\n    bytes32 config1 = CIP20Lib.createConfig(\n      32, /* digest size */\n      0,\n      0,\n      0,\n      32, /* leaf length */\n      0, /* node offset */\n      64, /* xof digest length*/\n      0,\n      32, /* inner length */\n      bytes8(0),\n      \"ULforxof\"\n    );\n    bytes32 config2 = CIP20Lib.createConfig(\n      32, /* digest size */\n      0,\n      0,\n      0,\n      32, /* leaf length */\n      1,\n      64, /* xof digest length*/\n      0,\n      32, /* inner length */\n      bytes8(0),\n      \"ULforxof\"\n    );\n    return\n      abi.encodePacked(\n        CIP20Lib.blake2sWithConfig(config1, \"\", data),\n        CIP20Lib.blake2sWithConfig(config2, \"\", data)\n      );\n  }\n\n  function parseToG1(bytes memory h, bytes memory hints, uint256 idx)\n    internal\n    view\n    returns (B12.G1Point memory)\n  {\n    bool greatest;\n    B12.Fp memory x;\n    (x, greatest) = B12.parsePoint(h);\n    return B12.mapToG1(x, B12.parseFp(hints, 0 + idx), B12.parseFp(hints, 64 + idx), greatest);\n  }\n\n  function parseToG1Scaled(bytes memory h, bytes memory hints)\n    internal\n    view\n    returns (B12.G1Point memory)\n  {\n    bool greatest;\n    B12.Fp memory x;\n    (x, greatest) = B12.parseRandomPoint(h);\n    return mapToG1Scaled(x, B12.parseFp(hints, 0), B12.parseFp(hints, 64), greatest);\n  }\n\n  function isValid(\n    uint16 epoch,\n    bytes memory data,\n    uint256 bitmap,\n    bytes memory sig,\n    bytes memory hints\n  ) internal view returns (bool) {\n    B12.G1Point memory p = parseToG1Scaled(doHash(data), hints);\n    bool prev = false;\n    B12.G2Point memory agg = B12.G2Point(\n      B12.Fp2(B12.Fp(0, 0), B12.Fp(0, 0)),\n      B12.Fp2(B12.Fp(0, 0), B12.Fp(0, 0))\n    );\n    B12.G2Point memory public_key = B12.G2Point(\n      B12.Fp2(B12.Fp(0, 0), B12.Fp(0, 0)),\n      B12.Fp2(B12.Fp(0, 0), B12.Fp(0, 0))\n    );\n    bytes memory buffer = new bytes(256);\n    uint256 blockNumber = getEpochLastBlock(epoch);\n    uint256 num = 0;\n    for (uint256 i = 0; i < 150; i++) {\n      if (bitmap & 1 == 1) {\n        num++;\n        getBLSPublicKeyInplace(blockNumber, i, public_key, buffer);\n        // public_key = getBLSPublicKey(blockNumber, i);\n        if (!prev) {\n          agg.X.a.a = public_key.X.a.a;\n          agg.X.b.a = public_key.X.b.a;\n          agg.Y.a.a = public_key.Y.a.a;\n          agg.Y.b.a = public_key.Y.b.a;\n          agg.X.a.b = public_key.X.a.b;\n          agg.X.b.b = public_key.X.b.b;\n          agg.Y.a.b = public_key.Y.a.b;\n          agg.Y.b.b = public_key.Y.b.b;\n          // agg = public_key;\n          prev = true;\n        } else {\n          agg = CeloB12_377Lib.g2Add(agg, public_key);\n        }\n      }\n      bitmap = bitmap >> 1;\n    }\n    require(num >= minQuorumSize(blockNumber), \"not enough signature\");\n    B12.G1Point memory sig_point = B12.parseG1(sig, 0);\n    B12.PairingArg[] memory args = new B12.PairingArg[](2);\n    args[0] = B12.PairingArg(sig_point, negativeP2());\n    args[1] = B12.PairingArg(p, agg);\n    return CeloB12_377Lib.pairing(args);\n  }\n\n}\n"
    },
    "@celo/protocol/contracts/common/libraries/CIP20Lib.sol": {
      "content": "//SPDX-License-Identifier: MIT OR Apache-2.0\n// From https://github.com/prestwich/cip20-sol\npragma solidity >=0.5.8;\n\nlibrary CIP20Lib {\n  uint8 private constant CIP20_ADDRESS = 0xf3;\n\n  uint8 private constant SHA3_256_SELECTOR = 0x00;\n  uint8 private constant SHA3_512_SELECTOR = 0x01;\n  uint8 private constant KECCAK_512_SELECTOR = 0x02;\n  uint8 private constant BLAKE2S_SELECTOR = 0x10;\n\n  bytes32 private constant BLAKE2S_DEFAULT_CONFIG = bytes32(\n    uint256(\n      (0x20 << (31 * 8)) | /* digest size */\n        (0x01 << (29 * 8)) | /* fan out */\n        (0x01 << (28 * 8)) /* depth */\n    )\n  );\n\n  // Accepts a fully formed input blob. This should include any config\n  // options and the preimage, but not the selector.\n  function executeCip20(bytes memory input, uint8 selector, uint256 output_len)\n    internal\n    view\n    returns (bytes memory)\n  {\n    uint8 addr = CIP20_ADDRESS;\n    bytes memory output = new bytes(output_len);\n\n    // To avoid copying the input array (an unbounded cost) we store its\n    // length on the stack and then replace the length prefix for its\n    // in-memory representation with the selector. We then replace the\n    // length in memory after the precompile executes with it.\n    uint256 len = input.length;\n\n    bool success;\n    assembly {\n      mstore(input, selector) // selector\n\n      success := staticcall(\n        sub(gas, 2000),\n        addr,\n        add(input, 0x1F), // location is shifted 1 byte for selector\n        add(len, 0x01), // length w/ selector\n        add(output, 0x20), // location\n        mload(output) // length\n      )\n\n      // Restore the input array length prefix\n      mstore(input, len)\n    }\n\n    require(success, \"keccak512 failed\");\n    return output;\n  }\n\n  function sha3_256(bytes memory input) internal view returns (bytes memory) {\n    return executeCip20(input, SHA3_256_SELECTOR, 32);\n  }\n\n  function sha3_512(bytes memory input) internal view returns (bytes memory) {\n    return executeCip20(input, SHA3_512_SELECTOR, 64);\n  }\n\n  function keccak512(bytes memory input) internal view returns (bytes memory) {\n    return executeCip20(input, KECCAK_512_SELECTOR, 64);\n  }\n\n  function blake2sWithConfig(bytes32 config, bytes memory key, bytes memory preimage)\n    internal\n    view\n    returns (bytes memory)\n  {\n    require(\n      key.length == uint256(config >> (8 * 30)) & 0xff,\n      \"CIP20Lib/blake2sWithConfig - Provided key length does not match key length in config\"\n    );\n    bytes memory configuredInput = abi.encodePacked(config, preimage);\n    return executeCip20(configuredInput, BLAKE2S_SELECTOR, uint256(uint8(config[0])));\n  }\n\n  // default settings, no key\n  function blake2s(bytes memory preimage) internal view returns (bytes memory) {\n    return blake2sWithConfig(BLAKE2S_DEFAULT_CONFIG, hex\"\", preimage);\n  }\n\n  function createConfig(\n    uint8 digestSize,\n    uint8 keyLength,\n    uint8 fanout,\n    uint8 depth,\n    uint32 leafLength,\n    uint32 nodeOffset,\n    uint16 xofDigestLength,\n    uint8 nodeDepth,\n    uint8 innerLength,\n    bytes8 salt,\n    bytes8 personalize\n  ) internal pure returns (bytes32 config) {\n    require(keyLength <= 32, \"CIP20Lib/createConfig -- keyLength must be 32 or less\");\n    config = writeU8(config, 0, digestSize);\n    config = writeU8(config, 1, keyLength);\n\n    config = writeU8(config, 2, fanout);\n    config = writeU8(config, 3, depth);\n    config = writeLEU32(config, 4, leafLength);\n    config = writeLEU32(config, 8, nodeOffset);\n    config = writeLEU16(config, 12, xofDigestLength);\n    config = writeU8(config, 14, nodeDepth);\n    config = writeU8(config, 15, innerLength);\n\n    config |= bytes32(uint256(uint64(salt))) << (8 * 8);\n    config |= bytes32(uint256(uint64(personalize))) << (8 * 0);\n    return config;\n  }\n\n  // This function relies on alignment mechanics. Explict conversion to\n  // `bytes` types shorter than 32 results in left re-alignment. To avoid\n  // that, we convert the bytes32 to uint256 instead of converting the uint8\n  // to a bytes1.\n  function writeU8(bytes32 b, uint8 offset, uint8 toWrite) private pure returns (bytes32) {\n    require(offset <= 31, \"CIP20Lib/writeU8 -- out of bounds write\");\n    uint8 shift = 8 * (32 - 1 - offset);\n    bytes32 res = bytes32(uint256(b) | (uint256(toWrite) << shift));\n    return res;\n  }\n\n  function writeLEU32(bytes32 b, uint8 offset, uint32 toWrite) private pure returns (bytes32) {\n    b = writeU8(b, offset + 0, uint8(toWrite >> 0));\n    b = writeU8(b, offset + 1, uint8(toWrite >> 8));\n    b = writeU8(b, offset + 2, uint8(toWrite >> 16));\n    b = writeU8(b, offset + 3, uint8(toWrite >> 24));\n    return b;\n  }\n\n  function writeLEU16(bytes32 b, uint8 offset, uint16 toWrite) private pure returns (bytes32) {\n    b = writeU8(b, offset + 0, uint8(toWrite >> 0));\n    b = writeU8(b, offset + 1, uint8(toWrite >> 8));\n    return b;\n  }\n}\n"
    },
    "@celo/protocol/contracts/common/interfaces/ICeloVersionedContract.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface ICeloVersionedContract {\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256);\n}\n"
    },
    "@celo/protocol/contracts/governance/SlasherUtil.sol": {
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\n\ncontract SlasherUtil is Ownable, Initializable, UsingRegistry, UsingPrecompiles {\n  using SafeMath for uint256;\n\n  struct SlashingIncentives {\n    // Value of LockedGold to slash from the account.\n    uint256 penalty;\n    // Value of LockedGold to send to the observer.\n    uint256 reward;\n  }\n\n  SlashingIncentives public slashingIncentives;\n\n  event SlashingIncentivesSet(uint256 penalty, uint256 reward);\n\n  /**\n   * @notice Sets slashing incentives.\n   * @param penalty Penalty for the slashed signer.\n   * @param reward Reward that the observer gets.\n   */\n  function setSlashingIncentives(uint256 penalty, uint256 reward) public onlyOwner {\n    require(penalty > reward, \"Penalty has to be larger than reward\");\n    slashingIncentives.penalty = penalty;\n    slashingIncentives.reward = reward;\n    emit SlashingIncentivesSet(penalty, reward);\n  }\n\n  /**\n   * @notice Returns the group to be slashed.\n   * @param validator Validator that was slashed.\n   * @param blockNumber Block number associated with slashing.\n   * @param groupMembershipHistoryIndex Index used for history lookup.\n   * @return Group to be slashed.\n   */\n  function groupMembershipAtBlock(\n    address validator,\n    uint256 blockNumber,\n    uint256 groupMembershipHistoryIndex\n  ) public view returns (address) {\n    uint256 epoch = getEpochNumberOfBlock(blockNumber);\n    require(epoch != 0, \"Cannot slash on epoch 0\");\n    // Use `epoch-1` because the elections were on that epoch\n    return\n      getValidators().groupMembershipInEpoch(validator, epoch.sub(1), groupMembershipHistoryIndex);\n  }\n\n  function performSlashing(\n    address validator,\n    address recipient,\n    uint256 startBlock,\n    uint256 groupMembershipHistoryIndex,\n    address[] memory validatorElectionLessers,\n    address[] memory validatorElectionGreaters,\n    uint256[] memory validatorElectionIndices,\n    address[] memory groupElectionLessers,\n    address[] memory groupElectionGreaters,\n    uint256[] memory groupElectionIndices\n  ) internal {\n    ILockedGold lockedGold = getLockedGold();\n    lockedGold.slash(\n      validator,\n      slashingIncentives.penalty,\n      recipient,\n      slashingIncentives.reward,\n      validatorElectionLessers,\n      validatorElectionGreaters,\n      validatorElectionIndices\n    );\n    address group = groupMembershipAtBlock(validator, startBlock, groupMembershipHistoryIndex);\n    assert(group != address(0));\n    lockedGold.slash(\n      group,\n      slashingIncentives.penalty,\n      recipient,\n      slashingIncentives.reward,\n      groupElectionLessers,\n      groupElectionGreaters,\n      groupElectionIndices\n    );\n    IValidators validators = getValidators();\n    validators.forceDeaffiliateIfValidator(validator);\n    validators.halveSlashingMultiplier(group);\n  }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@celo/protocol/contracts/common/Initializable.sol": {
      "content": "pragma solidity ^0.5.13;\n\ncontract Initializable {\n  bool public initialized;\n\n  modifier initializer() {\n    require(!initialized, \"contract already initialized\");\n    initialized = true;\n    _;\n  }\n}\n"
    },
    "@celo/protocol/contracts/common/UsingRegistry.sol": {
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\nimport \"./interfaces/IFeeCurrencyWhitelist.sol\";\nimport \"./interfaces/IFreezer.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\nimport \"../governance/interfaces/IElection.sol\";\nimport \"../governance/interfaces/IGovernance.sol\";\nimport \"../governance/interfaces/ILockedGold.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../identity/interfaces/IRandom.sol\";\nimport \"../identity/interfaces/IAttestations.sol\";\n\nimport \"../stability/interfaces/IExchange.sol\";\nimport \"../stability/interfaces/IReserve.sol\";\nimport \"../stability/interfaces/ISortedOracles.sol\";\nimport \"../stability/interfaces/IStableToken.sol\";\n\ncontract UsingRegistry is Ownable {\n  event RegistrySet(address indexed registryAddress);\n\n  // solhint-disable state-visibility\n  bytes32 constant ACCOUNTS_REGISTRY_ID = keccak256(abi.encodePacked(\"Accounts\"));\n  bytes32 constant ATTESTATIONS_REGISTRY_ID = keccak256(abi.encodePacked(\"Attestations\"));\n  bytes32 constant DOWNTIME_SLASHER_REGISTRY_ID = keccak256(abi.encodePacked(\"DowntimeSlasher\"));\n  bytes32 constant DOUBLE_SIGNING_SLASHER_REGISTRY_ID = keccak256(\n    abi.encodePacked(\"DoubleSigningSlasher\")\n  );\n  bytes32 constant ELECTION_REGISTRY_ID = keccak256(abi.encodePacked(\"Election\"));\n  bytes32 constant EXCHANGE_REGISTRY_ID = keccak256(abi.encodePacked(\"Exchange\"));\n  bytes32 constant FEE_CURRENCY_WHITELIST_REGISTRY_ID = keccak256(\n    abi.encodePacked(\"FeeCurrencyWhitelist\")\n  );\n  bytes32 constant FREEZER_REGISTRY_ID = keccak256(abi.encodePacked(\"Freezer\"));\n  bytes32 constant GOLD_TOKEN_REGISTRY_ID = keccak256(abi.encodePacked(\"GoldToken\"));\n  bytes32 constant GOVERNANCE_REGISTRY_ID = keccak256(abi.encodePacked(\"Governance\"));\n  bytes32 constant GOVERNANCE_SLASHER_REGISTRY_ID = keccak256(\n    abi.encodePacked(\"GovernanceSlasher\")\n  );\n  bytes32 constant LOCKED_GOLD_REGISTRY_ID = keccak256(abi.encodePacked(\"LockedGold\"));\n  bytes32 constant RESERVE_REGISTRY_ID = keccak256(abi.encodePacked(\"Reserve\"));\n  bytes32 constant RANDOM_REGISTRY_ID = keccak256(abi.encodePacked(\"Random\"));\n  bytes32 constant SNARK_EPOCH_DATA_SLASHER_REGISTRY_ID = keccak256(\n    abi.encodePacked(\"SnarkEpochDataSlasher\")\n  );\n  bytes32 constant SORTED_ORACLES_REGISTRY_ID = keccak256(abi.encodePacked(\"SortedOracles\"));\n  bytes32 constant STABLE_TOKEN_REGISTRY_ID = keccak256(abi.encodePacked(\"StableToken\"));\n  bytes32 constant VALIDATORS_REGISTRY_ID = keccak256(abi.encodePacked(\"Validators\"));\n  // solhint-enable state-visibility\n\n  IRegistry public registry;\n\n  modifier onlyRegisteredContract(bytes32 identifierHash) {\n    require(registry.getAddressForOrDie(identifierHash) == msg.sender, \"only registered contract\");\n    _;\n  }\n\n  modifier onlyRegisteredContracts(bytes32[] memory identifierHashes) {\n    require(registry.isOneOf(identifierHashes, msg.sender), \"only registered contracts\");\n    _;\n  }\n\n  /**\n   * @notice Updates the address pointing to a Registry contract.\n   * @param registryAddress The address of a registry contract for routing to other contracts.\n   */\n  function setRegistry(address registryAddress) public onlyOwner {\n    require(registryAddress != address(0), \"Cannot register the null address\");\n    registry = IRegistry(registryAddress);\n    emit RegistrySet(registryAddress);\n  }\n\n  function getAccounts() internal view returns (IAccounts) {\n    return IAccounts(registry.getAddressForOrDie(ACCOUNTS_REGISTRY_ID));\n  }\n\n  function getAttestations() internal view returns (IAttestations) {\n    return IAttestations(registry.getAddressForOrDie(ATTESTATIONS_REGISTRY_ID));\n  }\n\n  function getElection() internal view returns (IElection) {\n    return IElection(registry.getAddressForOrDie(ELECTION_REGISTRY_ID));\n  }\n\n  function getExchange() internal view returns (IExchange) {\n    return IExchange(registry.getAddressForOrDie(EXCHANGE_REGISTRY_ID));\n  }\n\n  function getFeeCurrencyWhitelistRegistry() internal view returns (IFeeCurrencyWhitelist) {\n    return IFeeCurrencyWhitelist(registry.getAddressForOrDie(FEE_CURRENCY_WHITELIST_REGISTRY_ID));\n  }\n\n  function getFreezer() internal view returns (IFreezer) {\n    return IFreezer(registry.getAddressForOrDie(FREEZER_REGISTRY_ID));\n  }\n\n  function getGoldToken() internal view returns (IERC20) {\n    return IERC20(registry.getAddressForOrDie(GOLD_TOKEN_REGISTRY_ID));\n  }\n\n  function getGovernance() internal view returns (IGovernance) {\n    return IGovernance(registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID));\n  }\n\n  function getLockedGold() internal view returns (ILockedGold) {\n    return ILockedGold(registry.getAddressForOrDie(LOCKED_GOLD_REGISTRY_ID));\n  }\n\n  function getRandom() internal view returns (IRandom) {\n    return IRandom(registry.getAddressForOrDie(RANDOM_REGISTRY_ID));\n  }\n\n  function getReserve() internal view returns (IReserve) {\n    return IReserve(registry.getAddressForOrDie(RESERVE_REGISTRY_ID));\n  }\n\n  function getSortedOracles() internal view returns (ISortedOracles) {\n    return ISortedOracles(registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID));\n  }\n\n  function getStableToken() internal view returns (IStableToken) {\n    return IStableToken(registry.getAddressForOrDie(STABLE_TOKEN_REGISTRY_ID));\n  }\n\n  function getValidators() internal view returns (IValidators) {\n    return IValidators(registry.getAddressForOrDie(VALIDATORS_REGISTRY_ID));\n  }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@celo/protocol/contracts/common/interfaces/IAccounts.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IAccounts {\n  function isAccount(address) external view returns (bool);\n  function voteSignerToAccount(address) external view returns (address);\n  function validatorSignerToAccount(address) external view returns (address);\n  function attestationSignerToAccount(address) external view returns (address);\n  function signerToAccount(address) external view returns (address);\n  function getAttestationSigner(address) external view returns (address);\n  function getValidatorSigner(address) external view returns (address);\n  function getVoteSigner(address) external view returns (address);\n  function hasAuthorizedVoteSigner(address) external view returns (bool);\n  function hasAuthorizedValidatorSigner(address) external view returns (bool);\n  function hasAuthorizedAttestationSigner(address) external view returns (bool);\n\n  function setAccountDataEncryptionKey(bytes calldata) external;\n  function setMetadataURL(string calldata) external;\n  function setName(string calldata) external;\n  function setWalletAddress(address, uint8, bytes32, bytes32) external;\n  function setAccount(string calldata, bytes calldata, address, uint8, bytes32, bytes32) external;\n\n  function getDataEncryptionKey(address) external view returns (bytes memory);\n  function getWalletAddress(address) external view returns (address);\n  function getMetadataURL(address) external view returns (string memory);\n  function batchGetMetadataURL(address[] calldata)\n    external\n    view\n    returns (uint256[] memory, bytes memory);\n  function getName(address) external view returns (string memory);\n\n  function authorizeVoteSigner(address, uint8, bytes32, bytes32) external;\n  function authorizeValidatorSigner(address, uint8, bytes32, bytes32) external;\n  function authorizeValidatorSignerWithPublicKey(address, uint8, bytes32, bytes32, bytes calldata)\n    external;\n  function authorizeValidatorSignerWithKeys(\n    address,\n    uint8,\n    bytes32,\n    bytes32,\n    bytes calldata,\n    bytes calldata,\n    bytes calldata\n  ) external;\n  function authorizeAttestationSigner(address, uint8, bytes32, bytes32) external;\n  function createAccount() external returns (bool);\n}\n"
    },
    "@celo/protocol/contracts/common/interfaces/IFeeCurrencyWhitelist.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IFeeCurrencyWhitelist {\n  function addToken(address) external;\n  function getWhitelist() external view returns (address[] memory);\n}\n"
    },
    "@celo/protocol/contracts/common/interfaces/IFreezer.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IFreezer {\n  function isFrozen(address) external view returns (bool);\n}\n"
    },
    "@celo/protocol/contracts/common/interfaces/IRegistry.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IRegistry {\n  function setAddressFor(string calldata, address) external;\n  function getAddressForOrDie(bytes32) external view returns (address);\n  function getAddressFor(bytes32) external view returns (address);\n  function isOneOf(bytes32[] calldata, address) external view returns (bool);\n}\n"
    },
    "@celo/protocol/contracts/governance/interfaces/IElection.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IElection {\n  function electValidatorSigners() external view returns (address[] memory);\n  function electNValidatorSigners(uint256, uint256) external view returns (address[] memory);\n  function vote(address, uint256, address, address) external returns (bool);\n  function activate(address) external returns (bool);\n  function revokeActive(address, uint256, address, address, uint256) external returns (bool);\n  function revokeAllActive(address, address, address, uint256) external returns (bool);\n  function revokePending(address, uint256, address, address, uint256) external returns (bool);\n  function markGroupIneligible(address) external;\n  function markGroupEligible(address, address, address) external;\n  function forceDecrementVotes(\n    address,\n    uint256,\n    address[] calldata,\n    address[] calldata,\n    uint256[] calldata\n  ) external returns (uint256);\n\n  // view functions\n  function getElectableValidators() external view returns (uint256, uint256);\n  function getElectabilityThreshold() external view returns (uint256);\n  function getNumVotesReceivable(address) external view returns (uint256);\n  function getTotalVotes() external view returns (uint256);\n  function getActiveVotes() external view returns (uint256);\n  function getTotalVotesByAccount(address) external view returns (uint256);\n  function getPendingVotesForGroupByAccount(address, address) external view returns (uint256);\n  function getActiveVotesForGroupByAccount(address, address) external view returns (uint256);\n  function getTotalVotesForGroupByAccount(address, address) external view returns (uint256);\n  function getActiveVoteUnitsForGroupByAccount(address, address) external view returns (uint256);\n  function getTotalVotesForGroup(address) external view returns (uint256);\n  function getActiveVotesForGroup(address) external view returns (uint256);\n  function getPendingVotesForGroup(address) external view returns (uint256);\n  function getGroupEligibility(address) external view returns (bool);\n  function getGroupEpochRewards(address, uint256, uint256[] calldata)\n    external\n    view\n    returns (uint256);\n  function getGroupsVotedForByAccount(address) external view returns (address[] memory);\n  function getEligibleValidatorGroups() external view returns (address[] memory);\n  function getTotalVotesForEligibleValidatorGroups()\n    external\n    view\n    returns (address[] memory, uint256[] memory);\n  function getCurrentValidatorSigners() external view returns (address[] memory);\n  function canReceiveVotes(address, uint256) external view returns (bool);\n  function hasActivatablePendingVotes(address, address) external view returns (bool);\n\n  // only owner\n  function setElectableValidators(uint256, uint256) external returns (bool);\n  function setMaxNumGroupsVotedFor(uint256) external returns (bool);\n  function setElectabilityThreshold(uint256) external returns (bool);\n\n  // only VM\n  function distributeEpochRewards(address, uint256, address, address) external;\n}\n"
    },
    "@celo/protocol/contracts/governance/interfaces/IGovernance.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IGovernance {\n  function isVoting(address) external view returns (bool);\n}\n"
    },
    "@celo/protocol/contracts/governance/interfaces/ILockedGold.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface ILockedGold {\n  function incrementNonvotingAccountBalance(address, uint256) external;\n  function decrementNonvotingAccountBalance(address, uint256) external;\n  function getAccountTotalLockedGold(address) external view returns (uint256);\n  function getTotalLockedGold() external view returns (uint256);\n  function getPendingWithdrawals(address)\n    external\n    view\n    returns (uint256[] memory, uint256[] memory);\n  function getTotalPendingWithdrawals(address) external view returns (uint256);\n  function lock() external payable;\n  function unlock(uint256) external;\n  function relock(uint256, uint256) external;\n  function withdraw(uint256) external;\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external;\n  function isSlasher(address) external view returns (bool);\n}\n"
    },
    "@celo/protocol/contracts/governance/interfaces/IValidators.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IValidators {\n  function registerValidator(bytes calldata, bytes calldata, bytes calldata)\n    external\n    returns (bool);\n  function deregisterValidator(uint256) external returns (bool);\n  function affiliate(address) external returns (bool);\n  function deaffiliate() external returns (bool);\n  function updateBlsPublicKey(bytes calldata, bytes calldata) external returns (bool);\n  function registerValidatorGroup(uint256) external returns (bool);\n  function deregisterValidatorGroup(uint256) external returns (bool);\n  function addMember(address) external returns (bool);\n  function addFirstMember(address, address, address) external returns (bool);\n  function removeMember(address) external returns (bool);\n  function reorderMember(address, address, address) external returns (bool);\n  function updateCommission() external;\n  function setNextCommissionUpdate(uint256) external;\n  function resetSlashingMultiplier() external;\n\n  // only owner\n  function setCommissionUpdateDelay(uint256) external;\n  function setMaxGroupSize(uint256) external returns (bool);\n  function setMembershipHistoryLength(uint256) external returns (bool);\n  function setValidatorScoreParameters(uint256, uint256) external returns (bool);\n  function setGroupLockedGoldRequirements(uint256, uint256) external returns (bool);\n  function setValidatorLockedGoldRequirements(uint256, uint256) external returns (bool);\n  function setSlashingMultiplierResetPeriod(uint256) external;\n\n  // view functions\n  function getMaxGroupSize() external view returns (uint256);\n  function getCommissionUpdateDelay() external view returns (uint256);\n  function getValidatorScoreParameters() external view returns (uint256, uint256);\n  function getMembershipHistory(address)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint256, uint256);\n  function calculateEpochScore(uint256) external view returns (uint256);\n  function calculateGroupEpochScore(uint256[] calldata) external view returns (uint256);\n  function getAccountLockedGoldRequirement(address) external view returns (uint256);\n  function meetsAccountLockedGoldRequirements(address) external view returns (bool);\n  function getValidatorBlsPublicKeyFromSigner(address) external view returns (bytes memory);\n  function getValidator(address account)\n    external\n    view\n    returns (bytes memory, bytes memory, address, uint256, address);\n  function getValidatorGroup(address)\n    external\n    view\n    returns (address[] memory, uint256, uint256, uint256, uint256[] memory, uint256, uint256);\n  function getGroupNumMembers(address) external view returns (uint256);\n  function getTopGroupValidators(address, uint256) external view returns (address[] memory);\n  function getGroupsNumMembers(address[] calldata accounts)\n    external\n    view\n    returns (uint256[] memory);\n  function getNumRegisteredValidators() external view returns (uint256);\n  function groupMembershipInEpoch(address, uint256, uint256) external view returns (address);\n\n  // only registered contract\n  function updateEcdsaPublicKey(address, address, bytes calldata) external returns (bool);\n  function updatePublicKeys(address, address, bytes calldata, bytes calldata, bytes calldata)\n    external\n    returns (bool);\n  function getValidatorLockedGoldRequirements() external view returns (uint256, uint256);\n  function getGroupLockedGoldRequirements() external view returns (uint256, uint256);\n  function getRegisteredValidators() external view returns (address[] memory);\n  function getRegisteredValidatorSigners() external view returns (address[] memory);\n  function getRegisteredValidatorGroups() external view returns (address[] memory);\n  function isValidatorGroup(address) external view returns (bool);\n  function isValidator(address) external view returns (bool);\n  function getValidatorGroupSlashingMultiplier(address) external view returns (uint256);\n  function getMembershipInLastEpoch(address) external view returns (address);\n  function getMembershipInLastEpochFromSigner(address) external view returns (address);\n\n  // only VM\n  function updateValidatorScoreFromSigner(address, uint256) external;\n  function distributeEpochPaymentsFromSigner(address, uint256) external returns (uint256);\n\n  // only slasher\n  function forceDeaffiliateIfValidator(address) external;\n  function halveSlashingMultiplier(address) external;\n\n}\n"
    },
    "@celo/protocol/contracts/identity/interfaces/IRandom.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IRandom {\n  function revealAndCommit(bytes32, bytes32, address) external;\n  function randomnessBlockRetentionWindow() external view returns (uint256);\n  function random() external view returns (bytes32);\n  function getBlockRandomness(uint256) external view returns (bytes32);\n}\n"
    },
    "@celo/protocol/contracts/identity/interfaces/IAttestations.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IAttestations {\n  function request(bytes32, uint256, address) external;\n  function selectIssuers(bytes32) external;\n  function complete(bytes32, uint8, bytes32, bytes32) external;\n  function revoke(bytes32, uint256) external;\n  function withdraw(address) external;\n  function approveTransfer(bytes32, uint256, address, address, bool) external;\n\n  // view functions\n  function getUnselectedRequest(bytes32, address) external view returns (uint32, uint32, address);\n  function getAttestationIssuers(bytes32, address) external view returns (address[] memory);\n  function getAttestationStats(bytes32, address) external view returns (uint32, uint32);\n  function batchGetAttestationStats(bytes32[] calldata)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint64[] memory, uint64[] memory);\n  function getAttestationState(bytes32, address, address)\n    external\n    view\n    returns (uint8, uint32, address);\n  function getCompletableAttestations(bytes32, address)\n    external\n    view\n    returns (uint32[] memory, address[] memory, uint256[] memory, bytes memory);\n  function getAttestationRequestFee(address) external view returns (uint256);\n  function getMaxAttestations() external view returns (uint256);\n  function validateAttestationCode(bytes32, address, uint8, bytes32, bytes32)\n    external\n    view\n    returns (address);\n  function lookupAccountsForIdentifier(bytes32) external view returns (address[] memory);\n  function requireNAttestationsRequested(bytes32, address, uint32) external view;\n\n  // only owner\n  function setAttestationRequestFee(address, uint256) external;\n  function setAttestationExpiryBlocks(uint256) external;\n  function setSelectIssuersWaitBlocks(uint256) external;\n  function setMaxAttestations(uint256) external;\n}\n"
    },
    "@celo/protocol/contracts/stability/interfaces/IExchange.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IExchange {\n  function buy(uint256, uint256, bool) external returns (uint256);\n  function sell(uint256, uint256, bool) external returns (uint256);\n  function exchange(uint256, uint256, bool) external returns (uint256);\n  function setUpdateFrequency(uint256) external;\n  function getBuyTokenAmount(uint256, bool) external view returns (uint256);\n  function getSellTokenAmount(uint256, bool) external view returns (uint256);\n  function getBuyAndSellBuckets(bool) external view returns (uint256, uint256);\n}\n"
    },
    "@celo/protocol/contracts/stability/interfaces/IReserve.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface IReserve {\n  function setTobinTaxStalenessThreshold(uint256) external;\n  function addToken(address) external returns (bool);\n  function removeToken(address, uint256) external returns (bool);\n  function transferGold(address payable, uint256) external returns (bool);\n  function transferExchangeGold(address payable, uint256) external returns (bool);\n  function getReserveGoldBalance() external view returns (uint256);\n  function getUnfrozenReserveGoldBalance() external view returns (uint256);\n  function getOrComputeTobinTax() external returns (uint256, uint256);\n  function getTokens() external view returns (address[] memory);\n  function getReserveRatio() external view returns (uint256);\n}\n"
    },
    "@celo/protocol/contracts/stability/interfaces/ISortedOracles.sol": {
      "content": "pragma solidity ^0.5.13;\n\ninterface ISortedOracles {\n  function addOracle(address, address) external;\n  function removeOracle(address, address, uint256) external;\n  function report(address, uint256, address, address) external;\n  function removeExpiredReports(address, uint256) external;\n  function isOldestReportExpired(address token) external view returns (bool, address);\n  function numRates(address) external view returns (uint256);\n  function medianRate(address) external view returns (uint256, uint256);\n  function numTimestamps(address) external view returns (uint256);\n  function medianTimestamp(address) external view returns (uint256);\n}\n"
    },
    "@celo/protocol/contracts/stability/interfaces/IStableToken.sol": {
      "content": "pragma solidity ^0.5.13;\n\n/**\n * @title This interface describes the functions specific to Celo Stable Tokens, and in the\n * absence of interface inheritance is intended as a companion to IERC20.sol and ICeloToken.sol.\n */\ninterface IStableToken {\n  function mint(address, uint256) external returns (bool);\n  function burn(uint256) external returns (bool);\n  function setInflationParameters(uint256, uint256) external;\n  function valueToUnits(uint256) external view returns (uint256);\n  function unitsToValue(uint256) external view returns (uint256);\n  function getInflationParameters() external view returns (uint256, uint256, uint256, uint256);\n\n  // NOTE: duplicated with IERC20.sol, remove once interface inheritance is supported.\n  function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "@celo/protocol/contracts/common/UsingPrecompiles.sol": {
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\n\ncontract UsingPrecompiles {\n  using SafeMath for uint256;\n\n  address constant TRANSFER = address(0xff - 2);\n  address constant FRACTION_MUL = address(0xff - 3);\n  address constant PROOF_OF_POSSESSION = address(0xff - 4);\n  address constant GET_VALIDATOR = address(0xff - 5);\n  address constant NUMBER_VALIDATORS = address(0xff - 6);\n  address constant EPOCH_SIZE = address(0xff - 7);\n  address constant BLOCK_NUMBER_FROM_HEADER = address(0xff - 8);\n  address constant HASH_HEADER = address(0xff - 9);\n  address constant GET_PARENT_SEAL_BITMAP = address(0xff - 10);\n  address constant GET_VERIFIED_SEAL_BITMAP = address(0xff - 11);\n  address constant VALIDATOR_BLS = address(0xff - 20);\n\n  /**\n   * @notice calculate a * b^x for fractions a, b to `decimals` precision\n   * @param aNumerator Numerator of first fraction\n   * @param aDenominator Denominator of first fraction\n   * @param bNumerator Numerator of exponentiated fraction\n   * @param bDenominator Denominator of exponentiated fraction\n   * @param exponent exponent to raise b to\n   * @param _decimals precision\n   * @return numerator/denominator of the computed quantity (not reduced).\n   */\n  function fractionMulExp(\n    uint256 aNumerator,\n    uint256 aDenominator,\n    uint256 bNumerator,\n    uint256 bDenominator,\n    uint256 exponent,\n    uint256 _decimals\n  ) public view returns (uint256, uint256) {\n    require(aDenominator != 0 && bDenominator != 0, \"a denominator is zero\");\n    uint256 returnNumerator;\n    uint256 returnDenominator;\n    bool success;\n    bytes memory out;\n    (success, out) = FRACTION_MUL.staticcall(\n      abi.encodePacked(aNumerator, aDenominator, bNumerator, bDenominator, exponent, _decimals)\n    );\n    require(success, \"error calling fractionMulExp precompile\");\n    returnNumerator = getUint256FromBytes(out, 0);\n    returnDenominator = getUint256FromBytes(out, 32);\n    return (returnNumerator, returnDenominator);\n  }\n\n  /**\n   * @notice Returns the current epoch size in blocks.\n   * @return The current epoch size in blocks.\n   */\n  function getEpochSize() public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = EPOCH_SIZE.staticcall(abi.encodePacked());\n    require(success, \"error calling getEpochSize precompile\");\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Returns the epoch number at a block.\n   * @param blockNumber Block number where epoch number is calculated.\n   * @return Epoch number.\n   */\n  function getEpochNumberOfBlock(uint256 blockNumber) public view returns (uint256) {\n    return epochNumberOfBlock(blockNumber, getEpochSize());\n  }\n\n  /**\n   * @notice Returns the epoch number at a block.\n   * @return Current epoch number.\n   */\n  function getEpochNumber() public view returns (uint256) {\n    return getEpochNumberOfBlock(block.number);\n  }\n\n  function getEpochLastBlock(uint256 epoch) public view returns (uint256) {\n    if (epoch == 0) {\n      return 0;\n    }\n    uint256 size = getEpochSize();\n    uint256 firstBlock = ((epoch - 1) * size) + 1;\n    return firstBlock + (size - 1);\n  }\n\n  /**\n   * @notice Returns the epoch number at a block.\n   * @param blockNumber Block number where epoch number is calculated.\n   * @param epochSize The epoch size in blocks.\n   * @return Epoch number.\n   */\n  function epochNumberOfBlock(uint256 blockNumber, uint256 epochSize)\n    internal\n    pure\n    returns (uint256)\n  {\n    // Follows GetEpochNumber from celo-blockchain/blob/master/consensus/istanbul/utils.go\n    uint256 epochNumber = blockNumber / epochSize;\n    if (blockNumber % epochSize == 0) {\n      return epochNumber;\n    } else {\n      return epochNumber.add(1);\n    }\n  }\n\n  /**\n   * @notice Gets a validator address from the current validator set.\n   * @param index Index of requested validator in the validator set.\n   * @return Address of validator at the requested index.\n   */\n  function validatorSignerAddressFromCurrentSet(uint256 index) public view returns (address) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VALIDATOR.staticcall(abi.encodePacked(index, uint256(block.number)));\n    require(success, \"error calling validatorSignerAddressFromCurrentSet precompile\");\n    return address(getUint256FromBytes(out, 0));\n  }\n\n  /**\n   * @notice Gets a validator address from the validator set at the given block number.\n   * @param index Index of requested validator in the validator set.\n   * @param blockNumber Block number to retrieve the validator set from.\n   * @return Address of validator at the requested index.\n   */\n  function validatorSignerAddressFromSet(uint256 index, uint256 blockNumber)\n    public\n    view\n    returns (address)\n  {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VALIDATOR.staticcall(abi.encodePacked(index, blockNumber));\n    require(success, \"error calling validatorSignerAddressFromSet precompile\");\n    return address(getUint256FromBytes(out, 0));\n  }\n\n  /**\n   * @notice Gets a validator address from the validator set at the given block number.\n   * @param index Index of requested validator in the validator set.\n   * @param blockNumber Block number to retrieve the validator set from.\n   * @return Address of validator at the requested index.\n   */\n  function validatorBLSPublicKeyFromSet(uint256 index, uint256 blockNumber)\n    public\n    view\n    returns (bytes memory)\n  {\n    bytes memory out;\n    bool success;\n    (success, out) = VALIDATOR_BLS.staticcall(abi.encodePacked(index, blockNumber));\n    require(success, \"error calling validatorBLSPublicKeyFromSet precompile\");\n    require(out.length == 256, \"bad BLS public key length\");\n    return out;\n  }\n\n  /**\n   * @notice Gets the size of the current elected validator set.\n   * @return Size of the current elected validator set.\n   */\n  function numberValidatorsInCurrentSet() public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = NUMBER_VALIDATORS.staticcall(abi.encodePacked(uint256(block.number)));\n    require(success, \"error calling numberValidatorsInCurrentSet precompile\");\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Gets the size of the validator set that must sign the given block number.\n   * @param blockNumber Block number to retrieve the validator set from.\n   * @return Size of the validator set.\n   */\n  function numberValidatorsInSet(uint256 blockNumber) public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = NUMBER_VALIDATORS.staticcall(abi.encodePacked(blockNumber));\n    require(success, \"error calling numberValidatorsInSet precompile\");\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Checks a BLS proof of possession.\n   * @param sender The address signed by the BLS key to generate the proof of possession.\n   * @param blsKey The BLS public key that the validator is using for consensus, should pass proof\n   *   of possession. 48 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 96 bytes.\n   * @return True upon success.\n   */\n  function checkProofOfPossession(address sender, bytes memory blsKey, bytes memory blsPop)\n    public\n    view\n    returns (bool)\n  {\n    bool success;\n    (success, ) = PROOF_OF_POSSESSION.staticcall(abi.encodePacked(sender, blsKey, blsPop));\n    return success;\n  }\n\n  /**\n   * @notice Parses block number out of header.\n   * @param header RLP encoded header\n   * @return Block number.\n   */\n  function getBlockNumberFromHeader(bytes memory header) public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = BLOCK_NUMBER_FROM_HEADER.staticcall(abi.encodePacked(header));\n    require(success, \"error calling getBlockNumberFromHeader precompile\");\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Computes hash of header.\n   * @param header RLP encoded header\n   * @return Header hash.\n   */\n  function hashHeader(bytes memory header) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = HASH_HEADER.staticcall(abi.encodePacked(header));\n    require(success, \"error calling hashHeader precompile\");\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Gets the parent seal bitmap from the header at the given block number.\n   * @param blockNumber Block number to retrieve. Must be within 4 epochs of the current number.\n   * @return Bitmap parent seal with set bits at indices corresponding to signing validators.\n   */\n  function getParentSealBitmap(uint256 blockNumber) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_PARENT_SEAL_BITMAP.staticcall(abi.encodePacked(blockNumber));\n    require(success, \"error calling getParentSealBitmap precompile\");\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Verifies the BLS signature on the header and returns the seal bitmap.\n   * The validator set used for verification is retrieved based on the parent hash field of the\n   * header.  If the parent hash is not in the blockchain, verification fails.\n   * @param header RLP encoded header\n   * @return Bitmap parent seal with set bits at indices correspoinding to signing validators.\n   */\n  function getVerifiedSealBitmapFromHeader(bytes memory header) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VERIFIED_SEAL_BITMAP.staticcall(abi.encodePacked(header));\n    require(success, \"error calling getVerifiedSealBitmapFromHeader precompile\");\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Converts bytes to uint256.\n   * @param bs byte[] data\n   * @param start offset into byte data to convert\n   * @return uint256 data\n   */\n  function getUint256FromBytes(bytes memory bs, uint256 start) internal pure returns (uint256) {\n    return uint256(getBytes32FromBytes(bs, start));\n  }\n\n  /**\n   * @notice Converts bytes to bytes32.\n   * @param bs byte[] data\n   * @param start offset into byte data to convert\n   * @return bytes32 data\n   */\n  function getBytes32FromBytes(bytes memory bs, uint256 start) internal pure returns (bytes32) {\n    require(bs.length >= start.add(32), \"slicing out of range\");\n    bytes32 x;\n    assembly {\n      x := mload(add(bs, add(start, 32)))\n    }\n    return x;\n  }\n\n  /**\n   * @notice Returns the minimum number of required signers for a given block number.\n   * @dev Computed in celo-blockchain as int(math.Ceil(float64(2*valSet.Size()) / 3))\n   */\n  function minQuorumSize(uint256 blockNumber) public view returns (uint256) {\n    return numberValidatorsInSet(blockNumber).mul(2).add(2).div(3);\n  }\n\n  /**\n   * @notice Computes byzantine quorum from current validator set size\n   * @return Byzantine quorum of validators.\n   */\n  function minQuorumSizeInCurrentSet() public view returns (uint256) {\n    return minQuorumSize(block.number);\n  }\n\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}